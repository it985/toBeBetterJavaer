const e=JSON.parse('{"key":"v-49acdbe9","path":"/thread/BlockingQueue.html","title":"吊打Java并发面试官之阻塞队列BlockingQueue","lang":"zh-CN","frontmatter":{"title":"吊打Java并发面试官之阻塞队列BlockingQueue","shortTitle":"BlockingQueue","description":"BlockingQueue 是 Java 中一个接口，它代表了一个线程安全的队列，不仅可以由多个线程并发访问，还添加了等待/通知机制，以便在队列为空时阻塞获取元素的线程，直到队列变得可用，或者在队列满时阻塞插入元素的线程，直到队列变得可用。","category":["Java核心"],"tag":["Java并发编程"],"head":[["meta",{"name":"keywords","content":"Java,并发编程,多线程,Thread,BlockingQueue"}],["meta",{"property":"og:url","content":"https://javabetter.cn/thread/BlockingQueue.html"}],["meta",{"property":"og:site_name","content":"二哥的Java进阶之路"}],["meta",{"property":"og:title","content":"吊打Java并发面试官之阻塞队列BlockingQueue"}],["meta",{"property":"og:description","content":"BlockingQueue 是 Java 中一个接口，它代表了一个线程安全的队列，不仅可以由多个线程并发访问，还添加了等待/通知机制，以便在队列为空时阻塞获取元素的线程，直到队列变得可用，或者在队列满时阻塞插入元素的线程，直到队列变得可用。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-13T02:41:36.000Z"}],["meta",{"property":"article:author","content":"沉默王二"}],["meta",{"property":"article:tag","content":"Java并发编程"}],["meta",{"property":"article:modified_time","content":"2024-04-13T02:41:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"吊打Java并发面试官之阻塞队列BlockingQueue\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-13T02:41:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"沉默王二\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"基本操作","slug":"基本操作","link":"#基本操作","children":[{"level":3,"title":"1）插入元素","slug":"_1-插入元素","link":"#_1-插入元素","children":[]},{"level":3,"title":"2）删除元素","slug":"_2-删除元素","link":"#_2-删除元素","children":[]},{"level":3,"title":"3）查找元素","slug":"_3-查找元素","link":"#_3-查找元素","children":[]}]},{"level":2,"title":"ArrayBlockingQueue","slug":"arrayblockingqueue","link":"#arrayblockingqueue","children":[{"level":3,"title":"1）put 方法详解","slug":"_1-put-方法详解","link":"#_1-put-方法详解","children":[]},{"level":3,"title":"2）take 方法详解","slug":"_2-take-方法详解","link":"#_2-take-方法详解","children":[]},{"level":3,"title":"3）使用示例","slug":"_3-使用示例","link":"#_3-使用示例","children":[]}]},{"level":2,"title":"LinkedBlockingQueue","slug":"linkedblockingqueue","link":"#linkedblockingqueue","children":[{"level":3,"title":"1）put 方法详解","slug":"_1-put-方法详解-1","link":"#_1-put-方法详解-1","children":[]},{"level":3,"title":"2）take 方法详解","slug":"_2-take-方法详解-1","link":"#_2-take-方法详解-1","children":[]},{"level":3,"title":"3）使用示例","slug":"_3-使用示例-1","link":"#_3-使用示例-1","children":[]}]},{"level":2,"title":"ArrayBlockingQueue 与 LinkedBlockingQueue 的比较","slug":"arrayblockingqueue-与-linkedblockingqueue-的比较","link":"#arrayblockingqueue-与-linkedblockingqueue-的比较","children":[]},{"level":2,"title":"PriorityBlockingQueue","slug":"priorityblockingqueue","link":"#priorityblockingqueue","children":[]},{"level":2,"title":"SynchronousQueue","slug":"synchronousqueue","link":"#synchronousqueue","children":[]},{"level":2,"title":"LinkedTransferQueue","slug":"linkedtransferqueue","link":"#linkedtransferqueue","children":[]},{"level":2,"title":"LinkedBlockingDeque","slug":"linkedblockingdeque","link":"#linkedblockingdeque","children":[]},{"level":2,"title":"DelayQueue","slug":"delayqueue","link":"#delayqueue","children":[]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1648037338000,"updatedTime":1712976096000,"contributors":[{"name":"itwanger","email":"www.qing_gee@163.com","commits":24},{"name":"沉默王二","email":"www.qing_gee@163.com","commits":3}]},"readingTime":{"minutes":20.23,"words":6069},"filePathRelative":"thread/BlockingQueue.md","localizedDate":"2022年3月23日","excerpt":"<h1> 第二十二节：阻塞队列 BlockingQueue</h1>\\n<p>BlockingQueue 是 Java 中的一个接口，它代表了一个线程安全的队列，不仅可以由多个线程并发访问，还添加了等待/通知机制，以便在队列为空时阻塞获取元素的线程，直到队列变得可用，或者在队列满时阻塞插入元素的线程，直到队列变得可用。</p>\\n<p>最常见的\\"<a href=\\"https://javabetter.cn/thread/shengchanzhe-xiaofeizhe.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">生产者-消费者</a>\\"问题中，队列通常被视作线程间的数据容器，生产者将“生产”出来的数据放入数据容器，消费者从“数据容器”中获取数据，这样，生产者线程和消费者线程就解耦了，各自只需要专注自己的业务即可。</p>"}');export{e as data};
