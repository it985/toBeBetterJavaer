import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o,c as p,a,d as n,b as e,e as t}from"./app-72970f25.js";const c={},r={href:"https://mp.weixin.qq.com/s/ptbM0EqlnCWeWm9VdSCDLg",target:"_blank",rel:"noopener noreferrer"},u={href:"https://mp.weixin.qq.com/s/SHkQ7LEOT0itt4bXMoDBPw",target:"_blank",rel:"noopener noreferrer"},d=a("h2",{id:"引言",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#引言","aria-hidden":"true"},"#"),n(" 引言")],-1),h=a("h3",{id:"_1-说说有哪些常见的集合框架",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_1-说说有哪些常见的集合框架","aria-hidden":"true"},"#"),n(" 1.说说有哪些常见的集合框架？")],-1),k={href:"https://javabetter.cn/collection/gailan.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://javabetter.cn/thread/BlockingQueue.html",target:"_blank",rel:"noopener noreferrer"},g=a("p",null,"Java 集合框架可以分为两条大的支线：",-1),v=a("p",null,"①、Collection，主要由 List、Set、Queue 组成：",-1),b={href:"https://javabetter.cn/collection/arraylist.html",target:"_blank",rel:"noopener noreferrer"},T={href:"https://javabetter.cn/collection/linkedlist.html",target:"_blank",rel:"noopener noreferrer"},Q=a("li",null,"Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；",-1),f={href:"https://javabetter.cn/collection/arraydeque.html",target:"_blank",rel:"noopener noreferrer"},_={href:"https://javabetter.cn/collection/PriorityQueue.html",target:"_blank",rel:"noopener noreferrer"},y={href:"https://javabetter.cn/collection/hashmap.html",target:"_blank",rel:"noopener noreferrer"},w=t('<figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/gailan-01.png" alt="二哥的 Java 进阶之路：Java集合主要关系" tabindex="0" loading="lazy"><figcaption>二哥的 Java 进阶之路：Java集合主要关系</figcaption></figure><p>概览图说明：</p><p>①、Collection 接口：最基本的集合框架表示方式，提供了添加、删除、清空等基本操作，它主要有三个子接口：</p><ul><li><code>List</code>：一个有序的集合，可以包含重复的元素。实现类包括 ArrayList、LinkedList 等。</li><li><code>Set</code>：一个不包含重复元素的集合。实现类包括 HashSet、LinkedHashSet、TreeSet 等。</li><li><code>Queue</code>：一个用于保持元素队列的集合。实现类包括 PriorityQueue、ArrayDeque 等。</li></ul><p>②、<code>Map</code> 接口：表示键值对的集合，一个键映射到一个值。键不能重复，每个键只能对应一个值。Map 接口的实现类包括 HashMap、LinkedHashMap、TreeMap 等。</p><p>集合框架位于 java.util 包下，该包含提供了两个常用的工具类：</p>',6),x={href:"https://javabetter.cn/common-tool/collections.html",target:"_blank",rel:"noopener noreferrer"},j={href:"https://javabetter.cn/common-tool/arrays.html",target:"_blank",rel:"noopener noreferrer"},M=t(`<h4 id="简单介绍一下队列-queue" tabindex="-1"><a class="header-anchor" href="#简单介绍一下队列-queue" aria-hidden="true">#</a> 简单介绍一下队列 Queue</h4><p>Java 中的队列主要通过 java.util.Queue 接口和 java.util.concurrent.BlockingQueue 两个接口来实现。</p><p>PriorityQueue 是一个基于优先级堆的无界队列，它的元素按照自然顺序排序或者 Comparator 进行排序。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/PriorityQueue-8dca2f55-a7c7-49e1-95a5-df1a34f2aef5.png" alt="李豪：优先级队列" tabindex="0" loading="lazy"><figcaption>李豪：优先级队列</figcaption></figure><p>ArrayDeque 是一个基于数组的双端队列，可以在两端插入和删除元素。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/arraydeque-1e7086a3-3d31-4553-aa16-5eaf2193649e.png" alt="李豪：双端队列" tabindex="0" loading="lazy"><figcaption>李豪：双端队列</figcaption></figure><p>还有一个大家可能忽略的队列，那就是 LinkedList，它既可以当作 List 使用，也可以当作 Queue 使用。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/list-war-2-02.png" alt="二哥的 Java 进阶之路" tabindex="0" loading="lazy"><figcaption>二哥的 Java 进阶之路</figcaption></figure><p>BlockingQueue 代表的是线程安全的队列，不仅可以由多个线程并发访问，还添加了等待/通知机制，以便在队列为空时阻塞获取元素的线程，直到队列变得可用，或者在队列满时阻塞插入元素的线程，直到队列变得可用。</p><p>阻塞队列（BlockingQueue）被广泛用于“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><p>BlockingQueue 接口的实现类有 ArrayBlockingQueue、DelayQueue、LinkedBlockingDeque、LinkedBlockingQueue、LinkedTransferQueue、PriorityBlockingQueue、SynchronousQueue 等。</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/BlockingQueue-20230818153420.png" alt="二哥的Java进阶之路" tabindex="0" loading="lazy"><figcaption>二哥的Java进阶之路</figcaption></figure><p>阻塞指的是一种程序执行状态，其中某个线程在等待某个条件满足时暂停其执行（即阻塞），直到条件满足时恢复其执行。</p><h4 id="阻塞队列是如何实现的" tabindex="-1"><a class="header-anchor" href="#阻塞队列是如何实现的" aria-hidden="true">#</a> 阻塞队列是如何实现的？</h4><p>就拿 ArrayBlockingQueue 来说，它是一个基于数组的有界阻塞队列，采用 ReentrantLock 锁来实现线程的互斥，而 ReentrantLock 底层采用的是 AQS 实现的队列同步，线程的阻塞调用 LockSupport.park 实现，唤醒调用 LockSupport.unpark 实现。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用ReentrantLock锁</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    <span class="token comment">// 获取锁</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果队列已满，阻塞</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 插入元素</span>
        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 插入元素
 */</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
    items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token comment">// 插入元素后，通知消费者线程可以继续取元素</span>
    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 获取元素
 */</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    <span class="token comment">// 获取锁</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果队列为空，阻塞，等待生产者线程放入元素</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 移除元素并返回</span>
        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 移除元素并返回
 */</span>
<span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
    <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 数组是循环队列，如果到达数组末尾，从头开始</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    count<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 移除元素后，通知生产者线程可以继续放入元素</span>
    notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="用过哪些集合类-它们的优劣" tabindex="-1"><a class="header-anchor" href="#用过哪些集合类-它们的优劣" aria-hidden="true">#</a> 用过哪些集合类，它们的优劣？</h4><p>在 Java 中，常用的集合类有 ArrayList、LinkedList、HashMap、LinkedHashMap 等。</p><ol><li><p>ArrayList：ArrayList 可以看作是一个动态数组，它可以在运行时动态扩容。优点是访问速度快，可以通过索引直接查到元素。缺点是插入和删除元素可能需要移动元素，效率就会降低。</p></li><li><p>LinkedList：LinkedList 是一个双向链表，它适合频繁的插入和删除操作。优点是插入和删除元素的时候只需要改变节点的前后指针，缺点是访问元素时需要遍历链表。</p></li><li><p>HashMap：HashMap 是一个基于哈希表的键值对集合。优点是插入、删除和查找元素的速度都很快。缺点是它不保留键值对的插入顺序。</p></li><li><p>LinkedHashMap：LinkedHashMap 在 HashMap 的基础上增加了一个双向链表来保持键值对的插入顺序。</p></li></ol><h4 id="队列和栈的区别了解吗" tabindex="-1"><a class="header-anchor" href="#队列和栈的区别了解吗" aria-hidden="true">#</a> 队列和栈的区别了解吗？</h4><p>队列是一种先进先出（FIFO, First-In-First-Out）的数据结构。在队列中，第一个加入队列的元素会是第一个被移除的。队列常用于处理按顺序来的任务。</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240412224341.png" alt="疯狂的技术宅：队列" tabindex="0" loading="lazy"><figcaption>疯狂的技术宅：队列</figcaption></figure><p>栈是一种后进先出（LIFO, Last-In-First-Out）的数据结构。在这种结构中，最后一个加入栈的元素会是第一个被移除的。这种特性使得栈非常适合于那些需要访问最新添加的数据元素的场合。</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240412224549.png" alt="Wang Wei：栈" tabindex="0" loading="lazy"><figcaption>Wang Wei：栈</figcaption></figure><h4 id="哪些是线程安全的" tabindex="-1"><a class="header-anchor" href="#哪些是线程安全的" aria-hidden="true">#</a> 哪些是线程安全的？</h4><p>像 Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue 这些都是线程安全的。</p>`,26),H={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},L={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},V={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},J={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},C={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},q={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},z={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},S={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},A={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},O={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},D={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},B={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Z=a("h2",{id:"list",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#list","aria-hidden":"true"},"#"),n(" List")],-1),E=a("h3",{id:"_2-arraylist-和-linkedlist-有什么区别",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_2-arraylist-和-linkedlist-有什么区别","aria-hidden":"true"},"#"),n(" 2.ArrayList 和 LinkedList 有什么区别？")],-1),K={href:"https://javabetter.cn/collection/list-war-2.html",target:"_blank",rel:"noopener noreferrer"},I=t('<p>ArrayList 和 LinkedList 的区别主要体现在数据结构、用途、是否支持随机访问、内存占用等方面。</p><h4 id="数据结构有什么不同" tabindex="-1"><a class="header-anchor" href="#数据结构有什么不同" aria-hidden="true">#</a> 数据结构有什么不同？</h4><ul><li>ArrayList 基于数组实现</li><li>LinkedList 基于链表实现</li></ul><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-2.png" alt="三分恶面渣逆袭：ArrayList和LinkedList的数据结构" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：ArrayList和LinkedList的数据结构</figcaption></figure><h4 id="用途有什么不同" tabindex="-1"><a class="header-anchor" href="#用途有什么不同" aria-hidden="true">#</a> 用途有什么不同？</h4><p>多数情况下，ArrayList 更利于查找，LinkedList 更利于增删</p><p>①、由于 ArrayList 是基于数组实现的，所以 <code>get(int index)</code> 可以直接通过数组下标获取，时间复杂度是 O(1)；LinkedList 是基于链表实现的，<code>get(int index)</code> 需要遍历链表，时间复杂度是 O(n)。</p><p>当然，<code>get(E element)</code> 这种查找，两种集合都需要遍历通过 equals 比较获取元素，所以时间复杂度都是 O(n)。</p><p>②、ArrayList 如果增删的是数组的尾部，直接插入或者删除就可以了，时间复杂度是 O(1)；如果 add 的时候涉及到扩容，时间复杂度会提升到 O(n)。</p><p>但如果插入的是中间的位置，就需要把插入位置后的元素向前或者向后移动，甚至还有可能触发扩容，效率就会低很多，O(n)。</p><p>LinkedList 因为是链表结构，插入和删除只需要改变前置节点、后置节点和插入节点的引用就行了，不需要移动元素。</p><p>如果是在链表的头部插入或者删除，时间复杂度是 O(1)；如果是在链表的中间插入或者删除，时间复杂度是 O(n)，因为需要遍历链表找到插入位置；如果是在链表的尾部插入或者删除，时间复杂度是 O(1)。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-3.png" alt="三分恶面渣逆袭：ArrayList和LinkedList中间插入" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：ArrayList和LinkedList中间插入</figcaption></figure><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-4.png" alt="三分恶面渣逆袭：ArrayList和LinkedList中间删除" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：ArrayList和LinkedList中间删除</figcaption></figure><p>注意，这里有个陷阱，LinkedList 更利于增删不是体现在时间复杂度上，因为二者增删的时间复杂度都是 O(n)，都需要遍历列表；而是体现在增删的效率上，因为 LinkedList 的增删只需要改变引用，而 ArrayList 的增删可能需要移动元素。</p><h4 id="是否支持随机访问" tabindex="-1"><a class="header-anchor" href="#是否支持随机访问" aria-hidden="true">#</a> 是否支持随机访问？</h4><p>①、ArrayList 是基于数组的，也实现了 RandomAccess 接口，所以它支持随机访问，可以通过下标直接获取元素。</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240319092907.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>②、LinkedList 是基于链表的，所以它没法根据下标直接获取元素，不支持随机访问，所以它也没有实现 RandomAccess 接口。</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240319093038.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="内存占用有何不同" tabindex="-1"><a class="header-anchor" href="#内存占用有何不同" aria-hidden="true">#</a> 内存占用有何不同？</h4><p>ArrayList 是基于数组的，是一块连续的内存空间，所以它的内存占用是比较紧凑的；但如果涉及到扩容，就会重新分配内存，空间是原来的 1.5 倍，存在一定的空间浪费。</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240319093453.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>LinkedList 是基于链表的，每个节点都有一个指向下一个节点和上一个节点的引用，于是每个节点占用的内存空间稍微大一点。</p>',24),N={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},G={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},R=t(`<h3 id="_3-arraylist-的扩容机制了解吗" tabindex="-1"><a class="header-anchor" href="#_3-arraylist-的扩容机制了解吗" aria-hidden="true">#</a> 3.ArrayList 的扩容机制了解吗？</h3><p>ArrayList 确切地说，应该叫做动态数组，因为它的底层是通过数组来实现的，当往 ArrayList 中添加元素时，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就会进行扩容。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-5.png" alt="三分恶面渣逆袭：ArrayList扩容" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：ArrayList扩容</figcaption></figure><p>扩容后的新数组长度是原来的 1.5 倍，然后再把原数组的值拷贝到新数组中。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// overflow-conscious code</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// minCapacity is usually close to size, so this is a win:</span>
    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),F={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},W=t(`<h3 id="_4-arraylist-怎么序列化的知道吗-为什么用-transient-修饰数组" tabindex="-1"><a class="header-anchor" href="#_4-arraylist-怎么序列化的知道吗-为什么用-transient-修饰数组" aria-hidden="true">#</a> 4.ArrayList 怎么序列化的知道吗？ 为什么用 transient 修饰数组？</h3><p>ArrayList 的序列化不太一样，它使用<code>transient</code>修饰存储元素的<code>elementData</code>的数组，<code>transient</code>关键字的作用是让被修饰的成员属性不被序列化。</p><p><strong>为什么最 ArrayList 不直接序列化元素数组呢？</strong></p><p>出于效率的考虑，数组可能长度 100，但实际只用了 50，剩下的 50 不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间。</p><p><strong>那 ArrayList 怎么序列化呢？</strong></p><p>ArrayList 通过两个方法<strong>readObject、writeObject</strong>自定义序列化和反序列化策略，实际直接使用两个流<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>来进行序列化和反序列化。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-6.png" alt="ArrayList自定义序列化" tabindex="0" loading="lazy"><figcaption>ArrayList自定义序列化</figcaption></figure><h3 id="_5-快速失败-fail-fast-和安全失败-fail-safe-了解吗" tabindex="-1"><a class="header-anchor" href="#_5-快速失败-fail-fast-和安全失败-fail-safe-了解吗" aria-hidden="true">#</a> 5.快速失败(fail-fast)和安全失败(fail-safe)了解吗？</h3><p><strong>快速失败（fail—fast）</strong>：快速失败是 Java 集合的一种错误检测机制</p><ul><li>在用迭代器遍历一个集合对象时，如果线程 A 遍历过程中，线程 B 对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。</li><li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <code> modCount</code> 变量。集合在被遍历期间如果内容发生变化，就会改变<code>modCount</code>的值。每当迭代器使用 hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的 bug。</li><li>场景：java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如 ArrayList 类。</li></ul><p><strong>安全失败（fail—safe）</strong></p><ul><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li><li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。</li><li>缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li><li>场景：java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如 CopyOnWriteArrayList 类。</li></ul><h3 id="_6-有哪几种实现-arraylist-线程安全的方法" tabindex="-1"><a class="header-anchor" href="#_6-有哪几种实现-arraylist-线程安全的方法" aria-hidden="true">#</a> 6.有哪几种实现 ArrayList 线程安全的方法？</h3><p>可以使用 <code>Collections.synchronizedList()</code> 方法，它将返回一个线程安全的 List。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SynchronizedList</span> list <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,15),P={href:"https://javabetter.cn/thread/synchronized-1.html",target:"_blank",rel:"noopener noreferrer"},X={href:"https://javabetter.cn/thread/CopyOnWriteArrayList.html",target:"_blank",rel:"noopener noreferrer"},Y=t(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">CopyOnWriteArrayList</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通俗的讲，CopyOnWrite 就是当我们往一个容器添加元素的时候，不直接往容器中添加，而是先复制出一个新的容器，然后在新的容器里添加元素，添加完之后，再将原容器的引用指向新的容器。多个线程在读的时候，不需要加锁，因为当前容器不会添加任何元素。这样就实现了线程安全。</p>`,2),U={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},$=a("h3",{id:"_7-copyonwritearraylist-了解多少",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_7-copyonwritearraylist-了解多少","aria-hidden":"true"},"#"),n(" 7.CopyOnWriteArrayList 了解多少？")],-1),aa=a("p",null,"CopyOnWriteArrayList 就是线程安全版本的 ArrayList。",-1),na=a("p",null,[n("它的名字叫"),a("code",null,"CopyOnWrite"),n("——写时复制，已经明示了它的原理。")],-1),sa=a("p",null,"CopyOnWriteArrayList 采用了一种读写分离的并发策略。CopyOnWriteArrayList 容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。",-1),ea=a("figure",null,[a("img",{src:"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-7.png",alt:"CopyOnWriteArrayList原理",tabindex:"0",loading:"lazy"}),a("figcaption",null,"CopyOnWriteArrayList原理")],-1),ta={href:"https://github.com/itwanger/toBeBetterJavaer",target:"_blank",rel:"noopener noreferrer"},oa={href:"https://javabetter.cn/overview/",target:"_blank",rel:"noopener noreferrer"},pa=t('<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><p>Map 中，毫无疑问，最重要的就是 HashMap，面试基本被盘出包浆了，各种问法，一定要好好准备。</p><h3 id="_8-能说一下-hashmap-的底层数据结构吗" tabindex="-1"><a class="header-anchor" href="#_8-能说一下-hashmap-的底层数据结构吗" aria-hidden="true">#</a> 8.能说一下 HashMap 的底层数据结构吗？</h3>',5),la={href:"https://javabetter.cn/collection/hashmap.html",target:"_blank",rel:"noopener noreferrer"},ia=t(`<p>JDK 8 中 HashMap 的数据结构是<code>数组</code>+<code>链表</code>+<code>红黑树</code>。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-8.png" alt="三分恶面渣逆袭：JDK 8 HashMap 数据结构示意图" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：JDK 8 HashMap 数据结构示意图</figcaption></figure><p>HashMap 的核心是一个动态数组（<code>Node[] table</code>），用于存储键值对。这个数组的每个元素称为一个“桶”（Bucket），每个桶的索引是通过对键的哈希值进行哈希函数处理得到的。</p><p>当多个键经哈希处理后得到相同的索引时，会发生哈希冲突。HashMap 通过链表来解决哈希冲突——即将具有相同索引的键值对通过链表连接起来。</p><p>不过，链表过长时，查询效率会比较低，于是当链表的长度超过 8 时（且数组的长度大于 64），链表就会转换为红黑树。红黑树的查询效率是 O(logn)，比链表的 O(n) 要快。数组的查询效率是 O(1)。</p><p>当向 HashMap 中添加一个键值对时，会使用哈希函数计算键的哈希码，确定其在数组中的位置，哈希函数的目标是尽量减少哈希冲突，保证元素能够均匀地分布在数组的每个位置上。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当向 HashMap 中添加元素时，如果该位置已有元素（发生哈希冲突），则新元素将被添加到链表的末尾或红黑树中。如果键已经存在，其对应的值将被新值覆盖。</p><p>当从 HashMap 中获取元素时，也会使用哈希函数计算键的位置，然后根据位置在数组、链表或者红黑树中查找元素。</p><p>HashMap 的初始容量是 16，随着元素的不断添加，HashMap 的容量（也就是数组大小）可能不足，于是就需要进行扩容，阈值是<code>capacity * loadFactor</code>，capacity 为容量，loadFactor 为负载因子，默认为 0.75。</p><p>扩容后的数组大小是原来的 2 倍，然后把原来的元素重新计算哈希值，放到新的数组中。</p><p>总的来说，HashMap 是一种通过哈希表实现的键值对集合，它通过将键哈希化成数组索引，并在冲突时使用链表或红黑树来存储元素，从而实现快速的查找、插入和删除操作。</p>`,12),ca={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ra={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ua={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},da={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ha={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ka={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ma={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ga={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},va=t('<h3 id="_9-你对红黑树了解多少-为什么不用二叉树-平衡树呢" tabindex="-1"><a class="header-anchor" href="#_9-你对红黑树了解多少-为什么不用二叉树-平衡树呢" aria-hidden="true">#</a> 9.你对红黑树了解多少？为什么不用二叉树/平衡树呢？</h3><p>红黑树是一种自平衡的二叉查找树：</p><ol><li>每个节点要么是红色，要么是黑色；</li><li>根节点永远是黑色；</li><li>所有的叶子节点都是是黑色的（下图中的 NULL 节点）；</li><li>红色节点的子节点一定是黑色的；</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-9.png" alt="三分恶面渣逆袭：红黑树" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：红黑树</figcaption></figure><h4 id="为什么不用二叉树" tabindex="-1"><a class="header-anchor" href="#为什么不用二叉树" aria-hidden="true">#</a> 为什么不用二叉树？</h4><p>二叉树是最基本的树结构，每个节点最多有两个子节点，但是二叉树容易出现极端情况，比如插入的数据是有序的，那么二叉树就会退化成链表，查询效率就会变成 O(n)。</p><h4 id="为什么不用平衡二叉树" tabindex="-1"><a class="header-anchor" href="#为什么不用平衡二叉树" aria-hidden="true">#</a> 为什么不用平衡二叉树？</h4><p>平衡二叉树比红黑树的要求更高，每个节点的左右子树的高度最多相差 1，这种高度的平衡保证了极佳的查找效率，但在进行插入和删除操作时，可能需要频繁地进行旋转来维持树的平衡，这在某些情况下可能导致更高的维护成本。</p><p>红黑树是一种折中的方案，它在保证了树平衡的同时，插入和删除操作的性能也得到了保证，查询效率是 O(logn)。</p>',9),ba={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Ta=t('<h3 id="_10-红黑树怎么保持平衡的" tabindex="-1"><a class="header-anchor" href="#_10-红黑树怎么保持平衡的" aria-hidden="true">#</a> 10.红黑树怎么保持平衡的？</h3><p>红黑树有两种方式保持平衡：<code>旋转</code>和<code>染色</code>。</p><p>①、旋转：旋转分为两种，左旋和右旋</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-10.png" alt="三分恶面渣逆袭：左旋" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：左旋</figcaption></figure><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-11.png" alt="三分恶面渣逆袭：右旋" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：右旋</figcaption></figure><p>②、染⾊：</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-12.png" alt="三分恶面渣逆袭：染色" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：染色</figcaption></figure>',7),Qa={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},fa=t(`<h3 id="_11-hashmap-的-put-流程知道吗" tabindex="-1"><a class="header-anchor" href="#_11-hashmap-的-put-流程知道吗" aria-hidden="true">#</a> 11.HashMap 的 put 流程知道吗？</h3><p>直接看流程图。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-13.jpg" alt="三分恶面渣逆袭：HashMap插入数据流程图" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：HashMap插入数据流程图</figcaption></figure><p>第一步，通过 hash 方法计算 key 的哈希值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二步，数组进行第一次扩容。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第三步，根据哈希值计算 key 在数组中的下标，如果对应下标正好没有存放数据，则直接插入。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果对应下标已经有数据了，就需要判断是否为相同的 key，是则覆盖 value，否则需要判断是否为树节点，是则向树中插入节点，否则向链表中插入数据。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        e <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
        e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，在链表中插入节点的时候，如果链表长度大于等于 8，则需要把链表转换为红黑树。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所有元素处理完后，还需要判断是否超过阈值<code>threshold</code>，超过则扩容。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
    <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="只重写-equals-没重写-hashcode-map-put-的时候会发生什么" tabindex="-1"><a class="header-anchor" href="#只重写-equals-没重写-hashcode-map-put-的时候会发生什么" aria-hidden="true">#</a> 只重写 equals 没重写 hashcode，map put 的时候会发生什么?</h4><p>如果只重写 equals 方法，没有重写 hashcode 方法，那么会导致 equals 相等的两个对象，hashcode 不相等，这样的话，这两个对象会被放到不同的桶中，这样就会导致 get 的时候，找不到对应的值。</p>`,17),_a={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ya={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},wa={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},xa=t(`<h3 id="_12-hashmap-怎么查找元素的呢" tabindex="-1"><a class="header-anchor" href="#_12-hashmap-怎么查找元素的呢" aria-hidden="true">#</a> 12.HashMap 怎么查找元素的呢？</h3><p>先看流程图：</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-14.png" alt="HashMap查找流程图" tabindex="0" loading="lazy"><figcaption>HashMap查找流程图</figcaption></figure><p>HashMap 的查找就简单很多：</p><ol><li>使用扰动函数，获取新的哈希值</li><li>计算数组下标，获取节点</li><li>当前节点和 key 匹配，直接返回</li><li>否则，当前节点是否为树节点，查找红黑树</li><li>否则，遍历链表查找</li></ol><h3 id="_13-hashmap-的-hash-函数是怎么设计的" tabindex="-1"><a class="header-anchor" href="#_13-hashmap-的-hash-函数是怎么设计的" aria-hidden="true">#</a> 13.HashMap 的 hash 函数是怎么设计的?</h3><p>HashMap 的哈希函数是先拿到 key 的 hashcode，是一个 32 位的 int 类型的数值，然后让 hashcode 的高 16 位和低 16 位进行异或操作。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token comment">// key的hashCode和key的hashCode右移16位做异或运算</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这么设计是为了降低哈希碰撞的概率。</p><h3 id="_14-为什么-hash-函数能降哈希碰撞" tabindex="-1"><a class="header-anchor" href="#_14-为什么-hash-函数能降哈希碰撞" aria-hidden="true">#</a> 14.为什么 hash 函数能降哈希碰撞？</h3><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240325100934.png" alt="JDK 8" tabindex="0" loading="lazy"><figcaption>JDK 8</figcaption></figure><p>在 hash 函数中，先调用了 key 的<code>hashCode()</code> 方法，这将会返回一个 int 类型的哈希值，比如说字符串的 hashCode。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            h <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> h <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        hash <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> h<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>int 的范围是 <strong>-2147483648~2147483647</strong>，加起来大概 40 亿上下的浮动。</p><p>只要 key 的 hashCode 方法设计的比较合理，一般是很难出现碰撞的。但问题是，不可能直接搞一个 40 亿长度的数组啊，那也太铺张浪费了。</p><p>我们一般会设置一个较小的数组长度，比如说 HashMap 的数组初始大小才 16，当发现容量不满足的时候再扩容，避免浪费。</p><p>那当数组长度比较小的时候，我们就需要设计一种比较巧妙的 hash 算法，来避免发生哈希冲突，尽可能地让元素均匀地分布在数组当中。</p><p>要达到这个目的，HashMap 在两方面下足了功夫，第一个就是数组的长度必须是 2 的整数次幂，这样可以保证 <code>hash &amp; (n-1)</code> 的结果能均匀地分布在数组中。</p><p>其作用就相当于 hash % n，n 为数组的长度，比如说数组长度是 16，hash 值为 20，那么 20 % 16 = 4，也就是说 20 这个元素应该放在数组的第 4 个位置；hash 值为 23，那么 23 % 16 = 7，也就是说 23 这个元素应该放在数组的第 7 个位置。</p><p><code>&amp;</code> 操作的结果就是哈希值的高位全部归零，只保留 n 个低位，用来做数组下标访问。</p>`,20),ja={class:"MathJax",jax:"SVG",style:{position:"relative"}},Ma={style:{"vertical-align":"-0.186ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.016ex",height:"2.09ex",role:"img",focusable:"false",viewBox:"0 -841.7 2659 923.7","aria-hidden":"true"},Ha=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1158.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2159,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g>',1),La=[Ha],Va=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mrow",{"data-mjx-texclass":"ORD"},[a("mn",null,"4")])]),a("mo",null,"−"),a("mn",null,"1")])],-1),Ja=t(`<p>以初始长度 16 为例，16-1=15。2 进制表示是<code>0000 0000 0000 0000 0000 0000 0000 1111</code>。和某个哈希值做 <code>&amp;</code> 运算，结果就是截取了最低的四位。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-15.png" alt="三分恶面渣逆袭：哈希&amp;运算" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：哈希&amp;运算</figcaption></figure><p>那问题又来了，那么大一个哈希值，也只取最后 4 位，不就等于哈希值的高位都丢弃了吗？</p><p>比如说 1111 1111 1111 1111 1111 1111 1111 1111，取最后 4 位，也就是 1111。</p><p>比如说 1110 1111 1111 1111 1111 1111 1111 1111，取最后 4 位，也是 1111。</p><p>不就发生哈希冲突了吗？</p><p>这时候 hash 函数 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 就派上用场了呀。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-16.jpg" alt="三分恶面渣逆袭：hash 函数示意图" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：hash 函数示意图</figcaption></figure><p>将哈希值无符号右移 16 位，意味着原哈希值的高 16 位被移到了低 16 位的位置。这样，原始哈希值的高 16 位和低 16 位就可以参与到最终用于索引计算的低位中。</p><p>选择 16 位是因为它是 32 位整数的一半，这样处理既考虑了高位的信息，又没有完全忽视低位原本的信息，尝试达到一个平衡状态。</p><p>举个例子（数组长度为 16）。</p><ul><li>第一个数：h1 = 0001 0010 0011 0100 0101 0110 0111 1000</li><li>第二个数：h2 = 0001 0010 0011 0101 0101 0110 0111 1000</li></ul><p>如果没有 hash 函数，直接取低 4 位，那么 h1 和 h2 的低 4 位都是 1000，也就是两个数都会放在数组的第 8 个位置。</p><p>来看一下 hash 函数的处理过程。</p><p>①、对于第一个数<code>h1</code>的计算：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>原始: 0001 0010 0011 0100 0101 0110 0111 1000
右移: 0000 0000 0000 0000 0001 0010 0011 0100
异或: ---------------------------------------
结果: 0001 0010 0011 0100 0100 0100 0100 1100
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>②、对于第二个数<code>h2</code>的计算：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>原始: 0001 0010 0011 0101 0101 0110 0111 1000
右移: 0000 0000 0000 0000 0001 0010 0011 0101
异或: ---------------------------------------
结果: 0001 0010 0011 0101 0100 0100 0100 1101
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上述计算，我们可以看到<code>h1</code>和<code>h2</code>经过<code>h ^ (h &gt;&gt;&gt; 16)</code>操作后得到了不同的结果。</p><p>现在，考虑数组长度为 16 时（需要最低 4 位来确定索引）：</p><ul><li>对于<code>h1</code>的最低 4 位是<code>1100</code>（十进制中为 12）</li><li>对于<code>h2</code>的最低 4 位是<code>1101</code>（十进制中为 13）</li></ul><p>这样，<code>h1</code>和<code>h2</code>就会被分别放在数组的第 12 个位置和第 13 个位置上，避免了哈希冲突。</p>`,22),Ca={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},qa=t(`<h3 id="_15-为什么-hashmap-的容量是-2-的倍数呢" tabindex="-1"><a class="header-anchor" href="#_15-为什么-hashmap-的容量是-2-的倍数呢" aria-hidden="true">#</a> 15.为什么 HashMap 的容量是 2 的倍数呢？</h3><p>HashMap 的容量是 2 的倍数，或者说是 2 的整数次幂，是为了快速定位元素的下标：</p><p>HashMap 在定位元素位置时，先通过 <code>hash(key) = (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 计算出哈希值，再通过 <code>hash &amp; (n-1)</code> 来定位元素位置的，n 为数组的大小，也就是 HashMap 的容量。</p><p>因为（数组长度-1）正好相当于一个“低位掩码”——这个掩码的低位最好全是 1，这样 &amp; 操作才有意义，否则结果就肯定是 0。</p><blockquote><p>a&amp;b 操作的结果是：a、b 中对应位同时为 1，则对应结果位为 1，否则为 0。例如 5&amp;3=1，5 的二进制是 0101，3 的二进制是 0011，5&amp;3=0001=1。</p></blockquote><p>2 的整次幂（或者叫 2 的整数倍）刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，保证了 <code>hash &amp;(length-1)</code> 的最后一位可能为 0，也可能为 1（取决于 hash 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，这样便可以保证哈希值的均匀分布。</p><p>换句话说，&amp; 操作的结果就是将哈希值的高位全部归零，只保留低位值。</p><p>假设某哈希值的二进制为 <code>10100101 11000100 00100101</code>，用它来做 &amp; 运算，我们来看一下结果。</p><p>我们知道，HashMap 的初始长度为 16，16-1=15，二进制是 <code>00000000 00000000 00001111</code>（高位用 0 来补齐）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>	 10100101 11000100 00100101
&amp;	 00000000 00000000 00001111
----------------------------------
	 00000000 00000000 00000101
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 15 的高位全部是 0，所以 &amp; 运算后的高位结果肯定也是 0，只剩下 4 个低位 <code>0101</code>，也就是十进制的 5。</p><p>这样，哈希值为 <code>10100101 11000100 00100101</code> 的键就会放在数组的第 5 个位置上。</p><h4 id="hashcode-对数组长度取模定位数组下标-这块有没有优化策略" tabindex="-1"><a class="header-anchor" href="#hashcode-对数组长度取模定位数组下标-这块有没有优化策略" aria-hidden="true">#</a> hashCode 对数组长度取模定位数组下标，这块有没有优化策略？</h4><p>我先说一下取模运算。</p><p>取模运算（Modulo Operation）和取余运算（Remainder Operation）从严格意义上来讲，是两种不同的运算方式，它们在计算机中的实现也不同。</p><p>在 Java 中，通常使用 % 运算符来表示取余，用 <code>Math.floorMod()</code> 来表示取模。</p><ul><li>当操作数都是正数的话，取模运算和取余运算的结果是一样的。</li><li>只有当操作数出现负数的情况，结果才会有所不同。</li><li><strong>取模运算的商向负无穷靠近；取余运算的商向 0 靠近</strong>。这是导致它们两个在处理有负数情况下，结果不同的根本原因。</li><li>当数组的长度是 2 的 n 次方，或者 n 次幂，或者 n 的整数倍时，取模运算/取余运算可以用位运算来代替，效率更高，毕竟计算机本身只认二进制嘛。</li></ul><p>比如说，7 对 3 取余，和 7 对 3 取模，结果都是 1。因为两者都是基于除法运算的，7 / 3 的商是 2，余数是 1。</p><p>于是，我们会在很多地方看到，<strong>取余就是取模，取模就是取余。</strong>。</p><p>对于 HashMap 来说，它需要通过 <code>hash % table.length</code> 来确定元素在数组中的位置，这种做法可以在很大程度上让元素均匀的分布在数组中。</p><p>比如说，数组长度是 3，hash 是 7，那么 7 % 3 的结果就是 1，也就是此时可以把元素放在下标为 1 的位置。</p><p>当 hash 是 8，8 % 3 的结果就是 2，也就是可以把元素放在下标为 2 的位置。</p><p>当 hash 是 9，9 % 3 的结果就是 0，也就是可以把元素放在下标为 0 的位置上。</p><p>是不是很奇妙，数组的大小为 3，刚好 3 个位置都利用上了。</p><p>那为什么 HashMap 在计算下标的时候，并没有直接使用取余运算（或者取模运算），而是直接使用位与运算 &amp; 呢？</p><p>这其实就是 HashMap 的一个优化策略。</p><p>因为当数组的长度是 2 的 n 次方时，<code>hash &amp; (length - 1) = hash % length</code>。</p><p>比如说 9 % 4 = 1，9 的二进制是 1001，4 - 1 = 3，3 的二进制是 0011，9 &amp; 3 = 1001 &amp; 0011 = 0001 = 1。</p><p>再比如说 10 % 4 = 2，10 的二进制是 1010，4 - 1 = 3，3 的二进制是 0011，10 &amp; 3 = 1010 &amp; 0011 = 0010 = 2。</p><p>当数组的长度不是 2 的 n 次方时，<code>hash % length</code> 和 <code>hash &amp; (length - 1)</code> 的结果就不一致了。</p><p>比如说 7 % 3 = 1，7 的二进制是 0111，3 - 1 = 2，2 的二进制是 0010，7 &amp; 2 = 0111 &amp; 0010 = 0010 = 2。</p>`,31),za={class:"MathJax",jax:"SVG",style:{position:"relative"}},Sa={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.279ex",height:"1.528ex",role:"img",focusable:"false",viewBox:"0 -675.5 1007.3 675.5","aria-hidden":"true"},Aa=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g>',1),Oa=[Aa],Da=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mi",null,"n")])])],-1),Ba={class:"MathJax",jax:"SVG",style:{position:"relative"}},Za={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.279ex",height:"1.528ex",role:"img",focusable:"false",viewBox:"0 -675.5 1007.3 675.5","aria-hidden":"true"},Ea=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g>',1),Ka=[Ea],Ia=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mi",null,"n")])])],-1),Na={class:"MathJax",jax:"SVG",style:{position:"relative"}},Ga={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.279ex",height:"1.528ex",role:"img",focusable:"false",viewBox:"0 -675.5 1007.3 675.5","aria-hidden":"true"},Ra=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g>',1),Fa=[Ra],Wa=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mi",null,"n")])])],-1),Pa={class:"MathJax",jax:"SVG",style:{position:"relative"}},Xa={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.279ex",height:"1.528ex",role:"img",focusable:"false",viewBox:"0 -675.5 1007.3 675.5","aria-hidden":"true"},Ya=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g>',1),Ua=[Ya],$a=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mi",null,"n")])])],-1),an={class:"MathJax",jax:"SVG",style:{position:"relative"}},nn={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.279ex",height:"1.528ex",role:"img",focusable:"false",viewBox:"0 -675.5 1007.3 675.5","aria-hidden":"true"},sn=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g>',1),en=[sn],tn=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mi",null,"n")])])],-1),on={class:"MathJax",jax:"SVG",style:{position:"relative"}},pn={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.885ex",role:"img",focusable:"false",viewBox:"0 -833.2 936.6 833.2","aria-hidden":"true"},ln=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g>',1),cn=[ln],rn=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"3")])])],-1),un={class:"MathJax",jax:"SVG",style:{position:"relative"}},dn={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.885ex",role:"img",focusable:"false",viewBox:"0 -833.2 936.6 833.2","aria-hidden":"true"},hn=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g>',1),kn=[hn],mn=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"3")])])],-1),gn=a("code",null,"hash % length",-1),vn={class:"MathJax",jax:"SVG",style:{position:"relative"}},bn={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.279ex",height:"1.528ex",role:"img",focusable:"false",viewBox:"0 -675.5 1007.3 675.5","aria-hidden":"true"},Tn=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g>',1),Qn=[Tn],fn=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mi",null,"n")])])],-1),_n={class:"MathJax",jax:"SVG",style:{position:"relative"}},yn={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.279ex",height:"1.528ex",role:"img",focusable:"false",viewBox:"0 -675.5 1007.3 675.5","aria-hidden":"true"},wn=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g>',1),xn=[wn],jn=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mi",null,"n")])])],-1),Mn={class:"MathJax",jax:"SVG",style:{position:"relative"}},Hn={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.279ex",height:"1.528ex",role:"img",focusable:"false",viewBox:"0 -675.5 1007.3 675.5","aria-hidden":"true"},Ln=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g>',1),Vn=[Ln],Jn=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mi",null,"n")])])],-1),Cn={class:"MathJax",jax:"SVG",style:{position:"relative"}},qn={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.885ex",role:"img",focusable:"false",viewBox:"0 -833.2 936.6 833.2","aria-hidden":"true"},zn=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g>',1),Sn=[zn],An=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"3")])])],-1),On=a("p",null,"010 对应于十进制中的 2，26 % 8 的结果是 2。",-1),Dn=a("p",null,[n("当执行"),a("code",null,"hash & (length - 1)"),n("时，实际上是保留 hash 二进制表示的最低 n 位，其他高位都被清零。")],-1),Bn=a("blockquote",null,[a("p",null,"& 与运算：两个操作数中位都为 1，结果才为 1，否则结果为 0。")],-1),Zn={class:"MathJax",jax:"SVG",style:{position:"relative"}},En={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.885ex",role:"img",focusable:"false",viewBox:"0 -833.2 936.6 833.2","aria-hidden":"true"},Kn=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g>',1),In=[Kn],Nn=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"3")])])],-1),Gn=t(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  1110 (hash = 14)
&amp; 0111 (length - 1 = 7)
  ----
  0110 (结果 = 6)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>保留 14 的最低 3 位，高位被清零。</p><p>从此，两个运算 <code>hash % length</code> 和 <code>hash &amp; (length - 1)</code> 有了完美的闭环。在计算机中，位运算的速度要远高于取余运算，因为计算机本质上就是二进制嘛。</p>`,3),Rn={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Fn={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Wn=t(`<h3 id="_16-如果初始化-hashmap-传一个-17-容量-它会怎么处理" tabindex="-1"><a class="header-anchor" href="#_16-如果初始化-hashmap-传一个-17-容量-它会怎么处理" aria-hidden="true">#</a> 16.如果初始化 HashMap，传一个 17 容量，它会怎么处理？</h3><p>HashMap 会将这个值转换为大于或等于 17 的最小的 2 的幂。这是因为 HashMap 的设计是基于哈希表的，而哈希表的大小最好是 2 的幂，这样可以优化哈希值的计算，并减少哈希冲突。</p><p>所以，如果你传入 17 作为初始容量，HashMap 实际上会被初始化为大小为 32 的哈希表。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-18.png" alt="三分恶面渣逆袭：容量计算" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：容量计算</figcaption></figure><p>在 HashMap 的初始化构造方法中，有这样⼀段代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>阀值 threshold 会通过⽅法<code> tableSizeFor()</code> 进⾏计算。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>①、<code>int n = cap - 1;</code> 将传入的容量减 1，用于确保如果传入的容量已经是 2 的幂次方，计算结果不会超过这个数。</p><p>②、接下来通过不断右移（<code>&gt;&gt;&gt;</code>）并与自身进行或运算（<code>|=</code>），将 n 的二进制表示中的所有低位设置为 1。</p><ul><li><code>n |= n &gt;&gt;&gt; 1;</code> 把 n 的二进制表示中最高位的 1 之后的一个 0 变成 1。</li><li><code>n |= n &gt;&gt;&gt; 2;</code> 接着把后两位中的 0 都变成 1。</li><li>依此类推，直到 <code>n |= n &gt;&gt;&gt; 16;</code>，此时 n 的二进制表示中，从最高位的 1 开始到最低位，都变成了 1。</li></ul><p>③、如果 n 小于 0，说明 cap 是负数，直接返回 1（理论上哈希表的大小不应该是负数或 0）。</p>`,12),Pn={class:"MathJax",jax:"SVG",style:{position:"relative"}},Xn={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.919ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 1290.1 833.9","aria-hidden":"true"},Yn=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g></g></g>',1),Un=[Yn],$n=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mrow",{"data-mjx-texclass":"ORD"},[a("mn",null,"30")])])])],-1),as=a("p",null,"否则，返回 n + 1，这是因为 n 的所有低位都是 1，所以 n + 1 就是大于 cap 的最小的 2 的幂次方。",-1),ns=a("h4",{id:"初始化-hashmap-的时候需要传入容量值吗",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#初始化-hashmap-的时候需要传入容量值吗","aria-hidden":"true"},"#"),n(" 初始化 HashMap 的时候需要传入容量值吗？")],-1),ss=a("p",null,"在创建 HashMap 时可以指定初始容量值。这个容量是指 Map 内部用于存储数据的数组大小。",-1),es=a("p",null,"如果预先知道 Map 将存储大量键值对，提前指定一个足够大的初始容量可以减少因扩容导致的重哈希（rehashing）操作，从而提高性能。",-1),ts=a("p",null,"因为每次扩容时，HashMap 需要新分配一个更大的数组并重新将现有的元素插入到这个新数组中，这个过程相对耗时，尤其是当 Map 中已有大量数据时。",-1),os=a("p",null,"当然了，过大的初始容量会浪费内存，特别是当实际存储的元素远少于初始容量时。如果不指定初始容量，HashMap 将使用默认的初始容量 16。",-1),ps={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ls=t('<h3 id="_17-你还知道哪些哈希函数的构造方法呢" tabindex="-1"><a class="header-anchor" href="#_17-你还知道哪些哈希函数的构造方法呢" aria-hidden="true">#</a> 17.你还知道哪些哈希函数的构造方法呢？</h3><p>HashMap 里哈希构造函数的方法叫：</p><ul><li><strong>除留取余法</strong>：<code>H(key)=key%p(p&lt;=N)</code>，关键字除以一个不大于哈希表长度的正整数 p，所得余数为地址，当然 HashMap 里进行了优化改造，效率更高，散列也更均衡。</li></ul><p>除此之外，还有这几种常见的哈希函数构造方法：</p><ul><li><p><strong>直接定址法</strong></p><p>直接根据<code>key</code>来映射到对应的数组位置，例如 1232 放到下标 1232 的位置。</p></li><li><p><strong>数字分析法</strong></p><p>取<code>key</code>的某些数字（例如十位和百位）作为映射的位置</p></li><li><p><strong>平方取中法</strong></p><p>取<code>key</code>平方的中间几位作为映射的位置</p></li><li><p><strong>折叠法</strong></p><p>将<code>key</code>分割成位数相同的几段，然后把它们的叠加和作为映射的位置</p></li></ul><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-19.png" alt="散列函数构造" tabindex="0" loading="lazy"><figcaption>散列函数构造</figcaption></figure><h3 id="_18-解决哈希冲突有哪些方法呢" tabindex="-1"><a class="header-anchor" href="#_18-解决哈希冲突有哪些方法呢" aria-hidden="true">#</a> 18.解决哈希冲突有哪些方法呢？</h3><p>解决哈希冲突的方法我知道的有 3 种：</p><p>①、再哈希法</p><p>准备两套哈希算法，当发生哈希冲突的时候，使用另外一种哈希算法，直到找到空槽为止。对哈希算法的设计要求比较高。</p><p>②、开放地址法</p><p>遇到哈希冲突的时候，就去寻找下一个空的槽。有 3 种方法：</p>',12),is=a("li",null,"线性探测：从冲突的位置开始，依次往后找，直到找到空槽。",-1),cs={class:"MathJax",jax:"SVG",style:{position:"relative"}},rs={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 936.6 833.9","aria-hidden":"true"},us=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g>',1),ds=[us],hs=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"1"),a("mn",null,"2")])])],-1),ks={class:"MathJax",jax:"SVG",style:{position:"relative"}},ms={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 936.6 833.9","aria-hidden":"true"},gs=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g>',1),vs=[gs],bs=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"2")])])],-1),Ts=a("li",null,"双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数。",-1),Qs=t(`<figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-20.png" alt="三分恶面渣逆袭：拉链法 VS 开放地址法" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：拉链法 VS 开放地址法</figcaption></figure><p>③、拉链法</p><p>也就是所谓的链地址法，当发生哈希冲突的时候，使用链表将冲突的元素串起来。HashMap 采用的正是拉链法。</p><h4 id="怎么判断-key-相等呢" tabindex="-1"><a class="header-anchor" href="#怎么判断-key-相等呢" aria-hidden="true">#</a> 怎么判断 key 相等呢？</h4><p><code>HashMap</code>判断两个<code>key</code>是否相等，依赖于<code>key</code>的<code>equals()</code>方法和<code>hashCode()</code>方法，以及 <code>==</code> 运算符。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>①、<strong>hashCode()</strong> ：首先，使用<code>key</code>的<code>hashCode()</code>方法计算<code>key</code>的哈希码。由于不同的<code>key</code>可能有相同的哈希码，<code>hashCode()</code>只是第一步筛选。</p><p>②、<strong>equals()</strong> ：当两个<code>key</code>的哈希码相同时，<code>HashMap</code>还会调用<code>key</code>的<code>equals()</code>方法进行精确比较。只有当<code>equals()</code>方法返回<code>true</code>时，两个<code>key</code>才被认为是完全相同的。</p><p>③、==：当然了，如果两个<code>key</code>的引用指向同一个对象，那么它们的<code>hashCode()</code>和<code>equals()</code>方法都会返回<code>true</code>，所以在 equals 判断之前会优先使用<code>==</code>运算符判断一次。</p>`,9),fs={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},_s=t(`<h3 id="_19-为什么-hashmap-链表转红黑树的阈值为-8-呢" tabindex="-1"><a class="header-anchor" href="#_19-为什么-hashmap-链表转红黑树的阈值为-8-呢" aria-hidden="true">#</a> 19.为什么 HashMap 链表转红黑树的阈值为 8 呢？</h3><p>树化发生在 table 数组的长度大于 64，且链表的长度大于 8 的时候。</p><p>为什么是 8 呢？源码的注释也给出了答案。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-21.png" alt="源码注释" tabindex="0" loading="lazy"><figcaption>源码注释</figcaption></figure><p>红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。</p><p>阈值为什么要选 8 呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为 8 的情况，发生概率仅为<code>0.00000006</code>。</p><p>至于红黑树转回链表的阈值为什么是 6，而不是 8？是因为如果这个阈值也设置成 8，假如发生碰撞，节点增减刚好在 8 附近，会发生链表和红黑树的不断转换，导致资源浪费。</p><h3 id="_20-扩容在什么时候呢-为什么扩容因子是-0-75" tabindex="-1"><a class="header-anchor" href="#_20-扩容在什么时候呢-为什么扩容因子是-0-75" aria-hidden="true">#</a> 20.扩容在什么时候呢？为什么扩容因子是 0.75？</h3><p>HashMap 会在存储的键值对数量超过阈值（即容量 * 加载因子）时进行扩容。</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240323113620.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>默认的加载因子是 0.75，这意味着当 HashMap 填满了大约 75%的容量时，就会进行扩容。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// aka 16</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认的初始容量是 16，那就是大于<code>16x0.75=12</code>时，就会触发第一次扩容操作。</p><h4 id="那么为什么选择了-0-75-作为-hashmap-的默认加载因子呢" tabindex="-1"><a class="header-anchor" href="#那么为什么选择了-0-75-作为-hashmap-的默认加载因子呢" aria-hidden="true">#</a> 那么为什么选择了 0.75 作为 HashMap 的默认加载因子呢？</h4><p>简单来说，这是对<code>空间</code>成本和<code>时间</code>成本平衡的考虑。</p><p>在 HashMap 中有这样一段注释：</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-24.png" alt="关于默认负载因子的注释" tabindex="0" loading="lazy"><figcaption>关于默认负载因子的注释</figcaption></figure><p>我们都知道，HashMap 的散列构造方式是 Hash 取余，负载因子决定元素个数达到多少时候扩容。</p><p>假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了。</p><p>我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了。</p>`,20),ys={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ws=t(`<h3 id="_21-那扩容机制了解吗" tabindex="-1"><a class="header-anchor" href="#_21-那扩容机制了解吗" aria-hidden="true">#</a> 21.那扩容机制了解吗？</h3><p>扩容时，HashMap 会创建一个新的数组，其容量是原数组容量的两倍。</p><p>然后将键值对放到新计算出的索引位置上。一部分索引不变，另一部分索引为“原索引+旧容量”。</p><p>在 JDK 7 中，定位元素位置的代码是这样的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span>
    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实就相当于用键的哈希值和数组大小取模，也就是 <code>hashCode % table.length</code>。</p><p>那我们来假设：</p><ul><li>数组 table 的长度为 2</li><li>键的哈希值为 3、7、5</li></ul><p>取模运算后，键发生了哈希冲突，都到 <code>table[1]</code> 上了。那么扩容前就是这个样子。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/hashmap-resize-01.png" alt="二哥的 Java 进阶之路：扩容前" tabindex="0" loading="lazy"><figcaption>二哥的 Java 进阶之路：扩容前</figcaption></figure><p>数组的容量为 2，key 为 3、7、5 的元素在 <code>table[1]</code> 上，需要通过拉链法来解决哈希冲突。</p><p>假设负载因子 loadFactor 为 1，也就是当元素的个数大于 table 的长度时进行扩容。</p><p>扩容后的数组容量为 4。</p><ul><li>key 3 取模（3%4）后是 3，放在 <code>table[3]</code> 上。</li><li>key 7 取模（7%4）后是 3，放在 <code>table[3]</code> 上的链表头部。</li><li>key 5 取模（5%4）后是 1，放在 <code>table[1]</code> 上。</li></ul><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/hashmap-resize-02.png" alt="二哥的 Java 进阶之路： JDK7扩容后" tabindex="0" loading="lazy"><figcaption>二哥的 Java 进阶之路： JDK7扩容后</figcaption></figure><p>7 跑到 3 的前面了，因为 JDK 7 使用的是头插法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>同时，扩容后的 5 跑到了下标为 1 的位置。</p><p>最好的情况就是，扩容后的 7 在 3 的后面，5 在 7 的后面，保持原来的顺序。</p><p>JDK 8 完全扭转了这个局面，因为 JDK 8 的哈希算法进行了优化，当数组长度为 2 的幂次方时，能够很巧妙地解决 JDK 7 中遇到的问题。</p><p>JDK 8 的扩容代码如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
        <span class="token keyword">int</span> newIndex <span class="token operator">=</span> hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算在新数组中的位置</span>
        <span class="token comment">// 将节点移动到新数组的对应位置</span>
        newTab<span class="token punctuation">[</span>newIndex<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新索引的计算方式是 <code>hash &amp; (newCapacity - 1)</code>，和 JDK 7 的 <code>h &amp; (length-1)</code>没什么大的差别，差别主要在 hash 方法上，JDK 8 是这样：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>过将键的<code>hashCode()</code>返回的 32 位哈希值与这个哈希值无符号右移 16 位的结果进行异或。</p><p>JDK 7 是这样：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Hashing</span><span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// This function ensures that hashCodes that differ only by</span>
    <span class="token comment">// constant multiples at each bit position have a bounded</span>
    <span class="token comment">// number of collisions (approximately 8 at default load factor).</span>
    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们用 JDK 8 的哈希算法来计算一下哈希值，就会发现别有洞天。</p>`,28),xs={class:"MathJax",jax:"SVG",style:{position:"relative"}},js={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 936.6 833.9","aria-hidden":"true"},Ms=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g>',1),Hs=[Ms],Ls=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"0")])])],-1),Vs={class:"MathJax",jax:"SVG",style:{position:"relative"}},Js={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 936.6 833.9","aria-hidden":"true"},Cs=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g>',1),qs=[Cs],zs=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"1")])])],-1),Ss={class:"MathJax",jax:"SVG",style:{position:"relative"}},As={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 936.6 833.9","aria-hidden":"true"},Os=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g>',1),Ds=[Os],Bs=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"2")])])],-1),Zs={class:"MathJax",jax:"SVG",style:{position:"relative"}},Es={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.885ex",role:"img",focusable:"false",viewBox:"0 -833.2 936.6 833.2","aria-hidden":"true"},Ks=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g>',1),Is=[Ks],Ns=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"3")])])],-1),Gs=a("ul",null,[a("li",null,"key1 和 n-1 做 & 运算后为 0000 0101，也就是 5；"),a("li",null,"key2 和 n-1 做 & 运算后为 0000 0101，也就是 5。"),a("li",null,"此时哈希冲突了，用拉链法来解决哈希冲突。")],-1),Rs={class:"MathJax",jax:"SVG",style:{position:"relative"}},Fs={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 936.6 833.9","aria-hidden":"true"},Ws=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g>',1),Ps=[Ws],Xs=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"0")])])],-1),Ys={class:"MathJax",jax:"SVG",style:{position:"relative"}},Us={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 936.6 833.9","aria-hidden":"true"},$s=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g>',1),ae=[$s],ne=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"1")])])],-1),se={class:"MathJax",jax:"SVG",style:{position:"relative"}},ee={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 936.6 833.9","aria-hidden":"true"},te=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g>',1),oe=[te],pe=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"2")])])],-1),le={class:"MathJax",jax:"SVG",style:{position:"relative"}},ie={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.885ex",role:"img",focusable:"false",viewBox:"0 -833.2 936.6 833.2","aria-hidden":"true"},ce=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g>',1),re=[ce],ue=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"3")])])],-1),de={class:"MathJax",jax:"SVG",style:{position:"relative"}},he={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.904ex",role:"img",focusable:"false",viewBox:"0 -841.7 936.6 841.7","aria-hidden":"true"},ke=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></g>',1),me=[ke],ge=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mn",null,"4")])])],-1),ve=t('<ul><li>key1 和 n-1 做 &amp; 运算后为 0000 0101，也就是 5；</li><li>key2 和 n-1 做 &amp; 运算后为 0001 0101，也就是 21=5+16，也就是数组扩容前的位置+原数组的长度。</li></ul><p>神奇吧？</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-26.png" alt="三分恶面渣逆袭：扩容位置变化" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：扩容位置变化</figcaption></figure><p>也就是说，在 JDK 8 的新 hash 算法下，数组扩容后的索引位置，要么就是原来的索引位置，要么就是“原索引+原来的容量”，遵循一定的规律。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-27.png" alt="三分恶面渣逆袭：扩容节点迁移示意图" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：扩容节点迁移示意图</figcaption></figure><p>当然了，这个功劳既属于新的哈希算法，也离不开 n 为 2 的整数次幂这个前提，这是它俩通力合作后的结果 <code>hash &amp; (newCapacity - 1)</code>。</p><h4 id="那你说说扩容的时候每个节点都要进行位运算吗-如果我这个-hashmap-里面有几十万条数据-都要进行位运算吗" tabindex="-1"><a class="header-anchor" href="#那你说说扩容的时候每个节点都要进行位运算吗-如果我这个-hashmap-里面有几十万条数据-都要进行位运算吗" aria-hidden="true">#</a> 那你说说扩容的时候每个节点都要进行位运算吗，如果我这个 HashMap 里面有几十万条数据，都要进行位运算吗？</h4><p>在 JDK 8 的新 hash 算法下，数组扩容后的索引位置，要么就是原来的索引位置，要么就是“原索引+原来的容量”，遵循一定的规律。</p><p>具体来说，就是判断原哈希值的高位中新增的那一位是否为 1，如果是，该元素会被移动到原位置加上旧容量的位置；如果不是，则保持在原位置。</p><p>所以，尽管有几十万条数据，每个数据项的位置决定仅需要一次简单的位运算。位运算的计算速度非常快，因此，尽管扩容操作涉及遍历整个哈希表并对每个节点进行操作，但这部分操作的计算成本是相对较低的。</p>',10),be={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Te={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Qe={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},fe={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},_e=t('<h3 id="_22-jdk-8-对-hashmap-主要做了哪些优化呢-为什么" tabindex="-1"><a class="header-anchor" href="#_22-jdk-8-对-hashmap-主要做了哪些优化呢-为什么" aria-hidden="true">#</a> 22.JDK 8 对 HashMap 主要做了哪些优化呢？为什么？</h3><p>相比较 JDK 7，JDK 8 的 HashMap 主要做了四点优化：</p><p>①、底层数据结构由数组 + 链表改成了数组 + 链表或红黑树的结构。</p><p>原因：如果多个键映射到了同一个哈希值，链表会变得很长，在最坏的情况下，当所有的键都映射到同一个桶中时，性能会退化到 O(n)，而红黑树的时间复杂度是 O(logn)。</p><p>②、链表的插入方式由头插法改为了尾插法。</p><p>原因：头插法虽然简单快捷，但扩容后容易改变原来链表的顺序。</p><p>③、扩容的时机由插入时判断改为插入后判断。</p><p>原因：可以避免在每次插入时都进行不必要的扩容检查，因为有可能插入后仍然不需要扩容。</p><p>④、优化了哈希算法。</p><p>JDK 7 进行了多次移位和异或操作来计算元素的哈希值。</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240512093223.png" alt="二哥的 Java 进阶之路：JDK 7 的 hash 方法" tabindex="0" loading="lazy"><figcaption>二哥的 Java 进阶之路：JDK 7 的 hash 方法</figcaption></figure><p>JDK 8 优化了这个算法，只进行了一次异或操作，但仍然能有效地减少冲突。</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240512093327.png" alt="二哥的 Java 进阶之路：JDK 8 的 hash 方法" tabindex="0" loading="lazy"><figcaption>二哥的 Java 进阶之路：JDK 8 的 hash 方法</figcaption></figure><p>并且能够保证扩容后，元素的新位置要么是原位置，要么是原位置加上旧容量大小。</p>',14),ye={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},we=a("h3",{id:"_23-你能自己设计实现一个-hashmap-吗",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_23-你能自己设计实现一个-hashmap-吗","aria-hidden":"true"},"#"),n(" 23.你能自己设计实现一个 HashMap 吗？")],-1),xe=a("p",null,[n("这道题"),a("strong",null,"快手"),n("常考。")],-1),je={href:"https://mp.weixin.qq.com/s/Z9yoRZW5itrtgbS-cj0bUg",target:"_blank",rel:"noopener noreferrer"},Me=t('<p>整体的设计：</p><ul><li>散列函数：hashCode()+除留余数法</li><li>冲突解决：链地址法</li><li>扩容：节点重新 hash 获取位置</li></ul><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-29.png" alt="自定义HashMap整体结构" tabindex="0" loading="lazy"><figcaption>自定义HashMap整体结构</figcaption></figure><p>完整代码：</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-30.png" alt="完整代码" tabindex="0" loading="lazy"><figcaption>完整代码</figcaption></figure><h3 id="_24-hashmap-是线程安全的吗-多线程下会有什么问题" tabindex="-1"><a class="header-anchor" href="#_24-hashmap-是线程安全的吗-多线程下会有什么问题" aria-hidden="true">#</a> 24.HashMap 是线程安全的吗？多线程下会有什么问题？</h3>',6),He={href:"https://javabetter.cn/collection/hashmap.html#_04%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8",target:"_blank",rel:"noopener noreferrer"},Le=t('<p>HashMap 不是线程安全的，主要有以下几个问题：</p><p>①、多线程下扩容会死循环。JDK1.7 中的 HashMap 使用的是头插法插入元素，在多线程的环境下，扩容的时候就有可能导致出现环形链表，造成死循环。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/hashmap-thread-nosafe-07.png" alt="二哥的 Java 进阶之路" tabindex="0" loading="lazy"><figcaption>二哥的 Java 进阶之路</figcaption></figure><p>不过，JDK 8 时已经修复了这个问题，扩容时会保持链表原来的顺序。</p><p>②、多线程的 put 可能会导致元素的丢失。因为计算出来的位置可能会被其他线程的 put 覆盖，很好理解。本来哈希冲突是应该用链表的，但多线程时由于没有加锁，相同位置的元素可能就被干掉了。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/hashmap-thread-nosafe-10.png" alt="二哥的 Java 进阶之路" tabindex="0" loading="lazy"><figcaption>二哥的 Java 进阶之路</figcaption></figure><p>③、put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而导致出现扩容，线程 2 此时执行 get，就有可能出现这个问题。</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240326085630.png" alt="二哥的 Java 进阶之路：源码截图" tabindex="0" loading="lazy"><figcaption>二哥的 Java 进阶之路：源码截图</figcaption></figure><p>因为线程 1 执行完 table = newTab 之后，线程 2 中的 table 此时也发生了变化，此时去 get 的时候当然会 get 到 null 了，因为元素还没有转移。</p>',9),Ve={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Je={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Ce={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},qe={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ze=a("h3",{id:"_25-有什么办法能解决-hashmap-线程不安全的问题呢",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_25-有什么办法能解决-hashmap-线程不安全的问题呢","aria-hidden":"true"},"#"),n(" 25.有什么办法能解决 HashMap 线程不安全的问题呢？")],-1),Se={href:"https://javabetter.cn/thread/ConcurrentHashMap.html",target:"_blank",rel:"noopener noreferrer"},Ae=a("code",null,"Collections.synchronizedMap(Map)",-1),Oe=a("p",null,"Hashtable 也是线程安全的，但它的使用已经不再推荐使用，因为 ConcurrentHashMap 提供了更高的并发性和性能。",-1),De={href:"https://javabetter.cn/thread/synchronized-1.html",target:"_blank",rel:"noopener noreferrer"},Be=a("figure",null,[a("img",{src:"https://cdn.tobebetterjavaer.com/stutymore/collection-20240323125211.png",alt:"二哥的 Java 进阶之路：HashTable",tabindex:"0",loading:"lazy"}),a("figcaption",null,"二哥的 Java 进阶之路：HashTable")],-1),Ze=a("code",null,"Collections.synchronizedMap",-1),Ee={href:"https://javabetter.cn/common-tool/collections.html",target:"_blank",rel:"noopener noreferrer"},Ke=a("figure",null,[a("img",{src:"https://cdn.tobebetterjavaer.com/stutymore/collection-20240323125418.png",alt:"二哥的 Java 进阶之路：Collections.synchronizedMap",tabindex:"0",loading:"lazy"}),a("figcaption",null,"二哥的 Java 进阶之路：Collections.synchronizedMap")],-1),Ie=a("p",null,"内部是通过 synchronized 对象锁来保证线程安全的。",-1),Ne={href:"https://javabetter.cn/thread/ConcurrentHashMap.html",target:"_blank",rel:"noopener noreferrer"},Ge={href:"https://javabetter.cn/thread/cas.html",target:"_blank",rel:"noopener noreferrer"},Re={href:"https://javabetter.cn/thread/synchronized-1.html",target:"_blank",rel:"noopener noreferrer"},Fe=a("figure",null,[a("img",{src:"https://cdn.tobebetterjavaer.com/stutymore/map-20230816155924.png",alt:"初念初恋：ConcurrentHashMap 8 中的实现",tabindex:"0",loading:"lazy"}),a("figcaption",null,"初念初恋：ConcurrentHashMap 8 中的实现")],-1),We={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Pe={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Xe={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Ye={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},Ue={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},$e=t('<h3 id="_26-hashmap-内部节点是有序的吗" tabindex="-1"><a class="header-anchor" href="#_26-hashmap-内部节点是有序的吗" aria-hidden="true">#</a> 26.HashMap 内部节点是有序的吗？</h3><p>HashMap 是无序的，根据 hash 值随机插入。如果想使用有序的 Map，可以使用 LinkedHashMap 或者 TreeMap。</p><h3 id="_27-讲讲-linkedhashmap-怎么实现有序的" tabindex="-1"><a class="header-anchor" href="#_27-讲讲-linkedhashmap-怎么实现有序的" aria-hidden="true">#</a> 27.讲讲 LinkedHashMap 怎么实现有序的？</h3><p>LinkedHashMap 维护了一个双向链表，有头尾节点，同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-33.png" alt="Entry节点" tabindex="0" loading="lazy"><figcaption>Entry节点</figcaption></figure><p>可以实现按插入的顺序或访问顺序排序。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-34.png" alt="LinkedHashMap实现原理" tabindex="0" loading="lazy"><figcaption>LinkedHashMap实现原理</figcaption></figure><h3 id="_28-讲讲-treemap-怎么实现有序的" tabindex="-1"><a class="header-anchor" href="#_28-讲讲-treemap-怎么实现有序的" aria-hidden="true">#</a> 28.讲讲 TreeMap 怎么实现有序的？</h3>',8),at={href:"https://javabetter.cn/collection/comparable-omparator.html",target:"_blank",rel:"noopener noreferrer"},nt=t('<figure><img src="https://cdn.tobebetterjavaer.com/stutymore/collection-20240330124711.png" alt="二哥的 Java 进阶之路" tabindex="0" loading="lazy"><figcaption>二哥的 Java 进阶之路</figcaption></figure><p>TreeMap 的底层是红黑树，红黑树是一种自平衡的二叉查找树，每个节点都大于其左子树中的任何节点，小于其右子节点树种的任何节点。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-35.png" alt="三分恶面渣逆袭：TreeMap" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：TreeMap</figcaption></figure><p>插入或者删除元素时通过旋转和着色来保持树的平衡。</p><p>查找的时候通过从根节点开始，利用二叉查找树的性质，逐步向左或者右子树递归查找，直到找到目标元素。</p><h3 id="_29-treemap-和-hashmap-的区别" tabindex="-1"><a class="header-anchor" href="#_29-treemap-和-hashmap-的区别" aria-hidden="true">#</a> 29.TreeMap 和 HashMap 的区别</h3><p>①、HashMap 是基于数组+链表+红黑树实现的，put 元素的时候会先计算 key 的哈希值，然后通过哈希值计算出数组的索引，然后将元素插入到数组中，如果发生哈希冲突，会使用链表来解决，如果链表长度大于 8，会转换为红黑树。</p><p>get 元素的时候同样会先计算 key 的哈希值，然后通过哈希值计算出数组的索引，如果遇到链表或者红黑树，会通过 key 的 equals 方法来判断是否是要找的元素。</p><p>②、TreeMap 是基于红黑树实现的，put 元素的时候会先判断根节点是否为空，如果为空，直接插入到根节点，如果不为空，会通过 key 的比较器来判断元素应该插入到左子树还是右子树。</p><p>get 元素的时候会通过 key 的比较器来判断元素的位置，然后递归查找。</p><p>由于 HashMap 是基于哈希表实现的，所以在没有发生哈希冲突的情况下，HashMap 的查找效率是 O(1)。适用于查找操作比较频繁的场景。</p><p>而 TreeMap 是基于红黑树实现的，所以 TreeMap 的查找效率是 O(logn)。并且保证了元素的顺序，因此适用于需要大量范围查找或者有序遍历的场景。</p>',12),st={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},et=t(`<h2 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h2><h3 id="_30-讲讲-hashset-的底层实现" tabindex="-1"><a class="header-anchor" href="#_30-讲讲-hashset-的底层实现" aria-hidden="true">#</a> 30.讲讲 HashSet 的底层实现？</h3><p>HashSet 其实是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5024744406713321676L</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>
    <span class="token comment">// Dummy value to associate with an Object in the backing Map</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ……</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么 ArrayList 和 LinkedList 可能更适合；如果我们需要存储键值对并根据键进行查找，那么 HashMap 可能更适合。</p><p>HashSet 主要用于去重，比如，我们需要统计一篇文章中有多少个不重复的单词，就可以使用 HashSet 来实现。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 创建一个 HashSet 对象</span>
<span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 添加元素</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;王二&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;陈清扬&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;沉默&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 输出 HashSet 的元素个数</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;HashSet size: &quot;</span> <span class="token operator">+</span> set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output: 3</span>

<span class="token comment">// 遍历 HashSet</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HashSet 会自动去重，因为它是用 HashMap 实现的，HashMap 的键是唯一的（哈希值），相同键的值会覆盖掉原来的值，于是第二次 set.add(&quot;沉默&quot;) 的时候就覆盖了第一次的 set.add(&quot;沉默&quot;)。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-36.png" alt="三分恶面渣逆袭：HashSet套娃" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：HashSet套娃</figcaption></figure><h4 id="hashset-和-arraylist-的区别" tabindex="-1"><a class="header-anchor" href="#hashset-和-arraylist-的区别" aria-hidden="true">#</a> HashSet 和 ArrayList 的区别</h4><ul><li>ArrayList 是基于动态数组实现的，HashSet 是基于 HashMap 实现的。</li><li>ArrayList 允许重复元素和 null 值，可以有多个相同的元素；HashSet 保证每个元素唯一，不允许重复元素，基于元素的 hashCode 和 equals 方法来确定元素的唯一性。</li><li>ArrayList 保持元素的插入顺序，可以通过索引访问元素；HashSet 不保证元素的顺序，元素的存储顺序依赖于哈希算法，并且可能随着元素的添加或删除而改变。</li></ul><h4 id="hashset-怎么判断元素重复-重复了是否-put" tabindex="-1"><a class="header-anchor" href="#hashset-怎么判断元素重复-重复了是否-put" aria-hidden="true">#</a> HashSet 怎么判断元素重复，重复了是否 put</h4><p>HashSet 的 add 方法是通过调用 HashMap 的 put 方法实现的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以 HashSet 判断元素重复的逻辑底层依然是 HashMap 的底层逻辑：</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-13.jpg" alt="三分恶面渣逆袭：HashMap插入数据流程图" tabindex="0" loading="lazy"><figcaption>三分恶面渣逆袭：HashMap插入数据流程图</figcaption></figure><p>HashMap 在插入元素时，通常需要三步：</p><p>第一步，通过 hash 方法计算 key 的哈希值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二步，数组进行第一次扩容。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第三步，根据哈希值计算 key 在数组中的下标，如果对应下标正好没有存放数据，则直接插入。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果对应下标已经有数据了，就需要判断是否为相同的 key，是则覆盖 value，否则需要判断是否为树节点，是则向树中插入节点，否则向链表中插入数据。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        e <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
        e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，HashSet 通过元素的哈希值来判断元素是否重复，如果重复了，会覆盖原来的值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>
    <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27),tt={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},ot={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},pt={href:"https://mp.weixin.qq.com/s/ptbM0EqlnCWeWm9VdSCDLg",target:"_blank",rel:"noopener noreferrer"},lt={href:"https://mp.weixin.qq.com/s/SHkQ7LEOT0itt4bXMoDBPw",target:"_blank",rel:"noopener noreferrer"},it=a("hr",null,null,-1),ct=a("p",null,[a("em",null,"没有什么使我停留——除了目的，纵然岸旁有玫瑰、有绿荫、有宁静的港湾，我是不系之舟"),n("。")],-1),rt=a("p",null,[a("strong",null,"系列内容"),n("：")],-1),ut={href:"https://javabetter.cn/sidebar/sanfene/javase.html",target:"_blank",rel:"noopener noreferrer"},dt={href:"https://javabetter.cn/sidebar/sanfene/javathread.html",target:"_blank",rel:"noopener noreferrer"},ht={href:"https://javabetter.cn/sidebar/sanfene/collection.html",target:"_blank",rel:"noopener noreferrer"},kt={href:"https://javabetter.cn/sidebar/sanfene/jvm.html",target:"_blank",rel:"noopener noreferrer"},mt={href:"https://javabetter.cn/sidebar/sanfene/spring.html",target:"_blank",rel:"noopener noreferrer"},gt={href:"https://javabetter.cn/sidebar/sanfene/redis.html",target:"_blank",rel:"noopener noreferrer"},vt={href:"https://javabetter.cn/sidebar/sanfene/mybatis.html",target:"_blank",rel:"noopener noreferrer"},bt={href:"https://javabetter.cn/sidebar/sanfene/mysql.html",target:"_blank",rel:"noopener noreferrer"},Tt={href:"https://javabetter.cn/sidebar/sanfene/os.html",target:"_blank",rel:"noopener noreferrer"},Qt={href:"https://javabetter.cn/sidebar/sanfene/network.html",target:"_blank",rel:"noopener noreferrer"},ft={href:"https://javabetter.cn/sidebar/sanfene/rocketmq.html",target:"_blank",rel:"noopener noreferrer"},_t={href:"https://javabetter.cn/sidebar/sanfene/fenbushi.html",target:"_blank",rel:"noopener noreferrer"},yt={href:"https://javabetter.cn/sidebar/sanfene/weifuwu.html",target:"_blank",rel:"noopener noreferrer"},wt={href:"https://javabetter.cn/sidebar/sanfene/shejimoshi.html",target:"_blank",rel:"noopener noreferrer"},xt={href:"https://javabetter.cn/sidebar/sanfene/linux.html",target:"_blank",rel:"noopener noreferrer"},jt=a("hr",null,null,-1),Mt={href:"https://github.com/itwanger/toBeBetterJavaer",target:"_blank",rel:"noopener noreferrer"},Ht={href:"https://javabetter.cn/overview/",target:"_blank",rel:"noopener noreferrer"},Lt=a("p",null,[n("微信搜 "),a("strong",null,"沉默王二"),n(" 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 "),a("strong",null,"222"),n(" 即可免费领取。")],-1),Vt=a("figure",null,[a("img",{src:"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png",alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1);function Jt(Ct,qt){const s=i("ExternalLinkIcon");return o(),p("div",null,[a("p",null,[n("7200 字 38 张手绘图，详解 29 道 Java 集合框架面试高频题（让天下没有难背的八股），面渣背会这些 Java 容器八股文，这次吊打面试官，我觉得稳了（手动 dog）。整理：沉默王二，戳"),a("a",r,[n("转载链接"),e(s)]),n("，作者：三分恶，戳"),a("a",u,[n("原文链接"),e(s)]),n("。")]),d,h,a("ul",null,[a("li",null,[n("推荐阅读："),a("a",k,[n("二哥的 Java 进阶之路：Java 集合框架"),e(s)])]),a("li",null,[n("推荐阅读："),a("a",m,[n("阻塞队列 BlockingQueue"),e(s)]),n("。")])]),g,v,a("ul",null,[a("li",null,[n("List 代表有序、可重复的集合，典型代表就是封装了动态数组的 "),a("a",b,[n("ArrayList"),e(s)]),n(" 和封装了链表的 "),a("a",T,[n("LinkedList"),e(s)]),n("；")]),Q,a("li",null,[n("Queue 代表队列，典型代表就是双端队列 "),a("a",f,[n("ArrayDeque"),e(s)]),n("，以及优先级队列 "),a("a",_,[n("PriorityQueue"),e(s)]),n("。")])]),a("p",null,[n("②、Map，代表键值对的集合，典型代表就是 "),a("a",y,[n("HashMap"),e(s)]),n("。")]),w,a("ul",null,[a("li",null,[a("a",x,[n("Collections"),e(s)]),n("：提供了一些对集合进行排序、二分查找、同步的静态方法。")]),a("li",null,[a("a",j,[n("Arrays"),e(s)]),n("：提供了一些对数组进行排序、打印、和 List 进行转换的静态方法。")])]),M,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",H,[n("Java 面试指南（付费）"),e(s)]),n("收录的用友金融一面原题：你了解哪些集合框架？")]),a("li",null,[a("a",L,[n("Java 面试指南（付费）"),e(s)]),n("收录的华为一面原题：说下 Java 容器和 HashMap")]),a("li",null,[a("a",V,[n("Java 面试指南（付费）"),e(s)]),n("收录的小米暑期实习同学 E 一面面试原题：你了解哪些集合？")]),a("li",null,[a("a",J,[n("Java 面试指南（付费）"),e(s)]),n("收录的美团面经同学 16 暑期实习一面面试原题：知道哪些集合，讲讲 HashMap 和 TreeMap 的区别，讲讲两者应用场景的区别；讲一下有哪些队列，阻塞队列的阻塞是什么含义？")]),a("li",null,[a("a",C,[n("Java 面试指南（付费）"),e(s)]),n("收录的农业银行面经同学 7 Java 后端面试原题：用过哪些集合类，它们的优劣")]),a("li",null,[a("a",q,[n("Java 面试指南（付费）"),e(s)]),n("收录的华为 OD 面经同学 1 一面面试原题：队列和栈的区别了解吗?")]),a("li",null,[a("a",z,[n("Java 面试指南（付费）"),e(s)]),n("收录的农业银行同学 1 面试原题：阻塞队列的实现方式")]),a("li",null,[a("a",S,[n("Java 面试指南（付费）"),e(s)]),n("收录的小公司面经合集同学 1 Java 后端面试原题：Java 容器有哪些？List、Set 还有 Map 的区别？")]),a("li",null,[a("a",A,[n("Java 面试指南（付费）"),e(s)]),n("收录的 360 面经同学 3 Java 后端技术一面面试原题：java 有哪些集合")]),a("li",null,[a("a",O,[n("Java 面试指南（付费）"),e(s)]),n("收录的华为面经同学 11 面试原题：java 中的集合类型？哪些是线程安全的？")]),a("li",null,[a("a",D,[n("Java 面试指南（付费）"),e(s)]),n("收录的招商银行面经同学 6 招银网络科技面试原题：Java 集合有哪些？")]),a("li",null,[a("a",B,[n("Java 面试指南（付费）"),e(s)]),n("收录的用友面试原题：集合容器能列举几个吗?")])])]),Z,E,a("p",null,[n("推荐阅读："),a("a",K,[n("二哥的 Java 进阶之路：ArrayList 和 LinkedList"),e(s)])]),I,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",N,[n("Java 面试指南（付费）"),e(s)]),n("收录的京东同学 10 后端实习一面的原题：ArrayList 和 LinkedList 的时间复杂度")]),a("li",null,[a("a",G,[n("Java 面试指南（付费）"),e(s)]),n("收录的小米暑期实习同学 E 一面面试原题：你了解哪些集合？")])])]),R,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",F,[n("Java 面试指南（付费）"),e(s)]),n("收录的联想面经同学 7 面试原题：Java 集合类介绍，挑一个讲原理。")])])]),W,a("p",null,[n("内部是通过 "),a("a",P,[n("synchronized 关键字"),e(s)]),n("加锁来实现的。")]),a("p",null,[n("也可以直接使用 "),a("a",X,[n("CopyOnWriteArrayList"),e(s)]),n("，它是线程安全的，遵循写时复制的原则，每当对列表进行修改（例如添加、删除或更改元素）时，都会创建列表的一个新副本，这个新副本会替换旧的列表，而对旧列表的所有读取操作仍然可以继续。")]),Y,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",U,[n("Java 面试指南（付费）"),e(s)]),n("收录的招商银行面经同学 6 招银网络科技面试原题：线程不安全的集合变成线程安全的方法？")])])]),$,aa,na,sa,ea,a("p",null,[n("GitHub 上标星 10000+ 的开源知识库《"),a("a",ta,[n("二哥的 Java 进阶之路"),e(s)]),n("》第一版 PDF 终于来了！包括 Java 基础语法、数组&字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳："),a("a",oa,[n("太赞了，GitHub 上标星 10000+ 的 Java 教程"),e(s)])]),pa,a("p",null,[n("推荐阅读："),a("a",la,[n("二哥的 Java 进阶之路：详解 HashMap"),e(s)])]),ia,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",ca,[n("Java 面试指南（付费）"),e(s)]),n("收录的小米 25 届日常实习一面原题：讲一讲 HashMap 的原理")]),a("li",null,[a("a",ra,[n("Java 面试指南（付费）"),e(s)]),n("收录的华为一面原题：说下 Java 容器和 HashMap")]),a("li",null,[a("a",ua,[n("Java 面试指南（付费）"),e(s)]),n("收录的华为一面原题：说下 Redis 和 HashMap 的区别")]),a("li",null,[a("a",da,[n("Java 面试指南（付费）"),e(s)]),n("收录的国企面试原题：说说 HashMap 的底层数据结构，链表和红黑树的转换，HashMap 的长度")]),a("li",null,[a("a",ha,[n("Java 面试指南（付费）"),e(s)]),n("收录的小米春招同学 K 一面面试原题：说一下 HashMap 数据库结构 和 一些重要参数")]),a("li",null,[a("a",ka,[n("Java 面试指南（付费）"),e(s)]),n("收录的腾讯云智面经同学 16 一面面试原题：HashMap 的底层实现，它为什么是线程不安全的？")]),a("li",null,[a("a",ma,[n("Java 面试指南（付费）"),e(s)]),n("收录的快手面经同学 1 部门主站技术部面试原题：HashMap 的结构？")]),a("li",null,[a("a",ga,[n("Java 面试指南（付费）"),e(s)]),n("收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：hashmap 的底层实现原理、put()方法实现流程、扩容机制？")])])]),va,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",ba,[n("Java 面试指南（付费）"),e(s)]),n("收录的携程面经同学 1 Java 后端技术一面面试原题：HashMap 为什么用红黑树，链表转数条件，红黑树插入删除规则")])])]),Ta,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",Qa,[n("Java 面试指南（付费）"),e(s)]),n("收录的携程面经同学 1 Java 后端技术一面面试原题：HashMap 为什么用红黑树，链表转数条件，红黑树插入删除规则")])])]),fa,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",_a,[n("Java 面试指南（付费）"),e(s)]),n("收录的京东同学 10 后端实习一面的原题：hashcode 和 equals 方法只重写一个行不行，只重写 equals 没重写 hashcode，map put 的时候会发生什么")]),a("li",null,[a("a",ya,[n("Java 面试指南（付费）"),e(s)]),n("收录的快手面经同学 1 部门主站技术部面试原题：HashMap 的 put 过程")]),a("li",null,[a("a",wa,[n("Java 面试指南（付费）"),e(s)]),n("收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：hashmap 的底层实现原理、put()方法实现流程、扩容机制？")])])]),xa,a("p",null,[n("比如说 hash & ("),a("mjx-container",ja,[(o(),p("svg",Ma,La)),Va]),n(") 的结果实际上是取 hash 的低 4 位，这四位能表示的取值范围刚好是 0000 到 1111，也就是 0 到 15，正好是数组长度为 16 的下标范围。")]),Ja,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",Ca,[n("Java 面试指南（付费）"),e(s)]),n("收录的支付宝面经同学 2 春招技术一面面试原题：为什么要用高低做异或运算？为什么非得高低 16 位异或？")])])]),qa,a("p",null,[n("因为从二进制角度来看，hash / length = hash / "),a("mjx-container",za,[(o(),p("svg",Sa,Oa)),Da]),n(" = hash >> n，即把 hash 右移 n 位，此时得到了 hash / "),a("mjx-container",Ba,[(o(),p("svg",Za,Ka)),Ia]),n(" 的商。")]),a("p",null,[n("而被移调的部分，则是 hash % "),a("mjx-container",Na,[(o(),p("svg",Ga,Fa)),Wa]),n("，也就是余数。")]),a("p",null,[a("mjx-container",Pa,[(o(),p("svg",Xa,Ua)),$a]),n(" 的二进制形式为 1，后面跟着 n 个 0，那 "),a("mjx-container",an,[(o(),p("svg",nn,en)),tn]),n(" - 1 的二进制则是 n 个 1。例如 8 = "),a("mjx-container",on,[(o(),p("svg",pn,cn)),rn]),n("，二进制是 1000，7 = "),a("mjx-container",un,[(o(),p("svg",dn,kn)),mn]),n(" - 1，二进制为 0111。")]),a("p",null,[gn,n("的操作是求 hash 除以 "),a("mjx-container",vn,[(o(),p("svg",bn,Qn)),fn]),n(" 的余数。在二进制中，这个操作的结果就是 hash 的二进制表示中最低 n 位的值。")]),a("p",null,[n("因为在 "),a("mjx-container",_n,[(o(),p("svg",yn,xn)),jn]),n(" 取模的操作中，高于 "),a("mjx-container",Mn,[(o(),p("svg",Hn,Vn)),Jn]),n(" 表示位的所有数值对结果没有贡献，只有低于这个阈值的部分才决定余数。")]),a("p",null,[n("比如说 26 的二进制是 11010，要计算 26 % 8，8 是 "),a("mjx-container",Cn,[(o(),p("svg",qn,Sn)),An]),n("，所以我们关注的是 26 的二进制表示中最低 3 位：11010 的最低 3 位是 010。")]),On,Dn,Bn,a("p",null,[n("举个例子，hash 为 14，n 为 3，也就是数组长度为 "),a("mjx-container",Zn,[(o(),p("svg",En,In)),Nn]),n("，也就是 8。")]),Gn,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",Rn,[n("Java 面试指南（付费）"),e(s)]),n("收录的小米春招同学 K 一面面试原题：为什么是 2 次幂 到什么时候开始扩容 扩容机制流程")]),a("li",null,[a("a",Fn,[n("Java 面试指南（付费）"),e(s)]),n("收录的支付宝面经同学 2 春招技术一面面试原题：hashCode 对数组长度取模定位数组下标，这块有没有优化策略？")])])]),Wn,a("p",null,[n("如果 n 大于或等于 MAXIMUM_CAPACITY（通常是"),a("mjx-container",Pn,[(o(),p("svg",Xn,Un)),$n]),n("），则返回 MAXIMUM_CAPACITY。")]),as,ns,ss,es,ts,os,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",ps,[n("Java 面试指南（付费）"),e(s)]),n("收录的奇安信面经同学 1 Java 技术一面面试原题：map 集合在使用时候一般都需要写容量值？为什么要写？扩容机制？")])])]),ls,a("ul",null,[is,a("li",null,[n("二次探测：从冲突的位置 x 开始，第一次增加 "),a("mjx-container",cs,[(o(),p("svg",rs,ds)),hs]),n(" 个位置，第二次增加 "),a("mjx-container",ks,[(o(),p("svg",ms,vs)),bs]),n("，直到找到空槽。")]),Ts]),Qs,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",fs,[n("Java 面试指南（付费）"),e(s)]),n("收录的支付宝面经同学 2 春招技术一面面试原题：HashMap 怎么解决冲突？怎么判断 key 相等？")])])]),_s,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",ys,[n("Java 面试指南（付费）"),e(s)]),n("收录的小米春招同学 K 一面面试原题：为什么是 2 次幂 到什么时候开始扩容 扩容机制流程")])])]),ws,a("p",null,[n("假设扩容前的数组长度为 16（n-1 也就是二进制的 0000 1111，1X"),a("mjx-container",xs,[(o(),p("svg",js,Hs)),Ls]),n("+1X"),a("mjx-container",Vs,[(o(),p("svg",Js,qs)),zs]),n("+1X"),a("mjx-container",Ss,[(o(),p("svg",As,Ds)),Bs]),n("+1X"),a("mjx-container",Zs,[(o(),p("svg",Es,Is)),Ns]),n("=1+2+4+8=15），key1 为 5（二进制为 0000 0101），key2 为 21（二进制为 0001 0101）。")]),Gs,a("p",null,[n("现在，HashMap 进行了扩容，容量为原来的 2 倍，也就是 32（n-1 也就是二进制的 0001 1111，1X"),a("mjx-container",Rs,[(o(),p("svg",Fs,Ps)),Xs]),n("+1X"),a("mjx-container",Ys,[(o(),p("svg",Us,ae)),ne]),n("+1X"),a("mjx-container",se,[(o(),p("svg",ee,oe)),pe]),n("+1X"),a("mjx-container",le,[(o(),p("svg",ie,re)),ue]),n("+1X"),a("mjx-container",de,[(o(),p("svg",he,me)),ge]),n("=1+2+4+8+16=31）。")]),ve,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",be,[n("Java 面试指南（付费）"),e(s)]),n("收录的小米春招同学 K 一面面试原题：为什么是 2 次幂 到什么时候开始扩容 扩容机制流程")]),a("li",null,[a("a",Te,[n("Java 面试指南（付费）"),e(s)]),n("收录的小米暑期实习同学 E 一面面试原题：说说 HashMap 的扩容机制，1.8 扩容具体实现")]),a("li",null,[a("a",Qe,[n("Java 面试指南（付费）"),e(s)]),n("收录的奇安信面经同学 1 Java 技术一面面试原题：map 集合在使用时候一般都需要写容量值？为什么要写？扩容机制？")]),a("li",null,[a("a",fe,[n("Java 面试指南（付费）"),e(s)]),n("收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：hashmap 的底层实现原理、put()方法实现流程、扩容机制？")])])]),_e,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",ye,[n("Java 面试指南（付费）"),e(s)]),n("收录的美团同学 2 优选物流调度技术 2 面面试原题：HashMap 的内部结构，1.7 和 1.8 的区别，有什么改进")])])]),we,xe,a("p",null,[n("不要慌，红黑树版咱们多半是写不出来，但是数组+链表版还是问题不大的，详细可见： "),a("a",je,[n("手写 HashMap，快手面试官直呼内行！"),e(s)]),n("。")]),Me,a("p",null,[n("推荐阅读："),a("a",He,[n("HashMap 详解"),e(s)])]),Le,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",Ve,[n("Java 面试指南（付费）"),e(s)]),n("收录的华为 OD 原题：HashMap 是线程安全的吗？")]),a("li",null,[a("a",Je,[n("Java 面试指南（付费）"),e(s)]),n("收录的华为面经同学 8 技术二面面试原题：HashMap 是线程安全的吗？")]),a("li",null,[a("a",Ce,[n("Java 面试指南（付费）"),e(s)]),n("收录的字节跳动面经同学 9 飞书后端技术一面面试原题：HashMap 为什么不安全，如何改进，以及 ConcurrentHashMap")]),a("li",null,[a("a",qe,[n("Java 面试指南（付费）"),e(s)]),n("收录的腾讯云智面经同学 16 一面面试原题：HashMap 的底层实现，它为什么是线程不安全的？")])])]),ze,a("p",null,[n("在 Java 中，有 3 种线程安全的 Map 实现，最常用的是"),a("a",Se,[n("ConcurrentHashMap"),e(s)]),n("和"),Ae,n("包装器。")]),Oe,a("p",null,[n("①、HashTable 是直接在方法上加 "),a("a",De,[n("synchronized 关键字"),e(s)]),n("，比较粗暴。")]),Be,a("p",null,[n("②、"),Ze,n(" 返回的是 "),a("a",Ee,[n("Collections"),e(s)]),n(" 工具类的内部类。")]),Ke,Ie,a("p",null,[n("③、"),a("a",Ne,[n("ConcurrentHashMap"),e(s)]),n(" 在 JDK 7 中使用分段锁，在 JKD 8 中使用了 "),a("a",Ge,[n("CAS（Compare-And-Swap）"),e(s)]),n("+ "),a("a",Re,[n("synchronized 关键字"),e(s)]),n("，性能得到进一步提升。")]),Fe,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",We,[n("Java 面试指南（付费）"),e(s)]),n("收录的小米春招同学 K 一面面试原题：有哪些线程安全的 map，ConcurrentHashMap 怎么保证线程安全的，为什么比 hashTable 效率好")]),a("li",null,[a("a",Pe,[n("Java 面试指南（付费）"),e(s)]),n("收录的华为面经同学 8 技术二面面试原题：Java 中的线程安全的集合是什么？")]),a("li",null,[a("a",Xe,[n("Java 面试指南（付费）"),e(s)]),n("收录的字节跳动面经同学 9 飞书后端技术一面面试原题：HashMap 为什么不安全，如何改进，以及 ConcurrentHashMap")]),a("li",null,[a("a",Ye,[n("Java 面试指南（付费）"),e(s)]),n("收录的腾讯云智面经同学 16 一面面试原题：知道哪些线程安全的集合类型？")]),a("li",null,[a("a",Ue,[n("Java 面试指南（付费）"),e(s)]),n("收录的招商银行面经同学 6 招银网络科技面试原题：线程不安全的集合变成线程安全的方法？")])])]),$e,a("p",null,[n("TreeMap 通过 key 的比较器来决定元素的顺序，如果没有指定比较器，那么 key 必须实现 "),a("a",at,[n("Comparable 接口"),e(s)]),n("。")]),nt,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",st,[n("Java 面试指南（付费）"),e(s)]),n("收录的美团面经同学 16 暑期实习一面面试原题：知道哪些集合，讲讲 HashMap 和 TreeMap 的区别，讲讲两者应用场景的区别")])])]),et,a("blockquote",null,[a("ol",null,[a("li",null,[a("a",tt,[n("Java 面试指南（付费）"),e(s)]),n("收录的京东同学 10 后端实习一面的原题：HashSet 和 ArrayList 的区别")]),a("li",null,[a("a",ot,[n("Java 面试指南（付费）"),e(s)]),n("收录的京东同学 10 后端实习一面的原题：HashSet 怎么判断元素重复，重复了是否 put")])])]),a("blockquote",null,[a("p",null,[n("图文详解 29 道 Java 集合框架面试高频题，这次吊打面试官，我觉得稳了（手动 dog）。整理：沉默王二，戳"),a("a",pt,[n("转载链接"),e(s)]),n("，作者：三分恶，戳"),a("a",lt,[n("原文链接"),e(s)]),n("。")])]),it,ct,rt,a("ul",null,[a("li",null,[a("a",ut,[n("面渣逆袭 Java SE 篇 👍"),e(s)])]),a("li",null,[a("a",dt,[n("面渣逆袭 Java 集合框架篇 👍"),e(s)])]),a("li",null,[a("a",ht,[n("面渣逆袭 Java 并发编程篇 👍"),e(s)])]),a("li",null,[a("a",kt,[n("面渣逆袭 JVM 篇 👍"),e(s)])]),a("li",null,[a("a",mt,[n("面渣逆袭 Spring 篇 👍"),e(s)])]),a("li",null,[a("a",gt,[n("面渣逆袭 Redis 篇 👍"),e(s)])]),a("li",null,[a("a",vt,[n("面渣逆袭 MyBatis 篇 👍"),e(s)])]),a("li",null,[a("a",bt,[n("面渣逆袭 MySQL 篇 👍"),e(s)])]),a("li",null,[a("a",Tt,[n("面渣逆袭操作系统篇 👍"),e(s)])]),a("li",null,[a("a",Qt,[n("面渣逆袭计算机网络篇 👍"),e(s)])]),a("li",null,[a("a",ft,[n("面渣逆袭 RocketMQ 篇 👍"),e(s)])]),a("li",null,[a("a",_t,[n("面渣逆袭分布式篇 👍"),e(s)])]),a("li",null,[a("a",yt,[n("面渣逆袭微服务篇 👍"),e(s)])]),a("li",null,[a("a",wt,[n("面渣逆袭设计模式篇 👍"),e(s)])]),a("li",null,[a("a",xt,[n("面渣逆袭 Linux 篇 👍"),e(s)])])]),jt,a("p",null,[n("GitHub 上标星 10000+ 的开源知识库《"),a("a",Mt,[n("二哥的 Java 进阶之路"),e(s)]),n("》第一版 PDF 终于来了！包括 Java 基础语法、数组&字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳："),a("a",Ht,[n("太赞了，GitHub 上标星 10000+ 的 Java 教程"),e(s)])]),Lt,Vt])}const At=l(c,[["render",Jt],["__file","collection.html.vue"]]);export{At as default};
