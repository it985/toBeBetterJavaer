import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as e,e as a}from"./app-wJXw8B29.js";const t={},n=a(`<p>这是一道场景题，当面试官问：</p><ul><li>订单超时怎么处理？</li><li>用户下单后有一个延迟 15 分钟的支付订单，怎么处理？</li></ul><p>我们该怎么回答呢？我在阿里云开发者账号上看到一个非常不错的内容，这里整理了一下分享给大家作为参考。</p><p>参考答案：</p><p>延迟支付订单的场景可以采用消息队列的延迟任务方案。即在用户下单时，将订单放入一个延迟队列中，延迟 15 分钟检查支付状态，超时未支付则取消订单。这种方式可以在高并发下有效降低系统负担，减少数据库轮询压力，并通过消息队列的自动调度机制确保订单准时处理。同时，这个设计可以通过消息的幂等性、分布式部署等手段提升系统的可靠性和扩展性。</p><p>好，接下来，我们来分析一下。</p><p>在企业的商业活动中，订单是指交易双方的产品或服务交易意向。交易下单负责创建这个交易双方的产品或服务交易意向，有了这个意向后，买方可以付款，卖方可以发货。</p><p>在电商场景下，买卖双方没有面对面交易，许多情况下需要通过超时处理自动关闭订单，下面是一个订单的流程：</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-40480773-4e86-49fc-b283-bc0a3948f0ca.jpg" alt="阿里云开发者：订单流程" tabindex="0" loading="lazy"><figcaption>阿里云开发者：订单流程</figcaption></figure><p>如上图所示，一个订单流程中有许多环节要用到超时处理，包括但不限于：</p><ul><li>买家超时未付款：比如超过 15 分钟没有支付，订单自动取消。</li><li>商家超时未发货：比如商家超过 1 个月没发货，订单自动取消。</li><li>买家超时未收货：比如商家发货后，买家没有在 14 天内点击确认收货，则系统默认自动收货。</li></ul><h2 id="一、jdk-自带的延时队列" tabindex="-1"><a class="header-anchor" href="#一、jdk-自带的延时队列"><span>一、JDK 自带的延时队列</span></a></h2><p>JDK 中提供了一种延迟队列数据结构 DelayQueue，其本质是封装了 PriorityQueue，可以把元素进行排序。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-525e94ca-96e1-4308-a010-fc96702fb6ef.jpg" alt="阿里云开发者：JDK 自带的延迟队列" tabindex="0" loading="lazy"><figcaption>阿里云开发者：JDK 自带的延迟队列</figcaption></figure><ol><li>把订单插入 DelayQueue 中，以超时时间作为排序条件，将订单按照超时时间从小到大排序。</li><li>起一个线程不停轮询队列的头部，如果订单的超时时间到了，就出队进行超时处理，并更新订单状态到数据库中。</li><li>为了防止机器重启导致内存中的 DelayQueue 数据丢失，每次机器启动的时候，需要从数据库中初始化未结束的订单，加入到 DelayQueue 中。</li></ol><p>优点：简单，不需要借助其他第三方组件，成本低。</p><p>缺点：</p><ul><li>所有超时处理订单都要加入到 DelayQueue 中，占用内存大。</li><li>没法做到分布式处理，只能在集群中选一台 leader 专门处理，效率低。</li><li>不适合订单量比较大的场景。</li></ul><h2 id="二、rabbitmq-延时消息" tabindex="-1"><a class="header-anchor" href="#二、rabbitmq-延时消息"><span>二、RabbitMQ 延时消息</span></a></h2><p>RabbitMQ 的延时消息主要有两个解决方案：</p><ul><li>RabbitMQ Delayed Message Plugin</li><li>消息的 TTL+死信 Exchange</li></ul><p>RabbitMQ Delayed Message Plugin 是官方提供的延时消息插件，虽然使用起来比较方便，但不是高可用的，如果节点挂了会导致消息丢失。引用官网原文：</p><blockquote><p>Delayed messages are stored in a Mnesia table (also see Limitations below) with a single disk replica on the current node. They will survive a node restart. While timer(s) that triggered scheduled delivery are not persisted, it will be re-initialised during plugin activation on node start. Obviously, only having one copy of a scheduled message in a cluster means that losing that node or disabling the plugin on it will lose the messages residing on that node.</p></blockquote><p>消息的 TTL+死信 Exchange 解决方案，先要了解两个概念：</p><p>①、TTL：即消息的存活时间。RabbitMQ 可以对队列和消息分别设置 TTL，如果对队列设置，则队列中所有的消息都具有相同的过期时间。超过了这个时间，我们认为这个消息就死了，称之为死信。</p><p>②、死信 Exchange（DLX）：一个消息在满足以下条件会进入死信交换机</p><ul><li>一个消息被 Consumer 拒收了，并且 reject 方法的参数里 requeue 是 false。也就是说不会被再次放在队列里，被其他消费者使用。</li><li>TTL 到期的消息。</li><li>队列满了被丢弃的消息。</li></ul><p>一个延时消息的流程如下图：</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-1937308e-17bd-4fa4-af0d-7df1c2887b10.jpg" alt="阿里云开发者：延时消息" tabindex="0" loading="lazy"><figcaption>阿里云开发者：延时消息</figcaption></figure><ol><li>定义一个 BizQueue，用来接收死信消息，并进行业务消费。</li><li>定义一个死信交换机(DLXExchange)，绑定 BizQueue，接收延时队列的消息，并转发给 BizQueue。</li><li>定义一组延时队列 DelayQueue_xx，分别配置不同的 TTL，用来处理固定延时 5s、10s、30s 等延时等级，并绑定到 DLXExchange。</li><li>定义 DelayExchange，用来接收业务发过来的延时消息，并根据延时时间转发到不同的延时队列中。</li></ol><p>优点：可以支持海量延时消息，支持分布式处理。</p><p>缺点：</p><ul><li>不灵活，只能支持固定延时等级。</li><li>使用复杂，要配置一堆延时队列。</li></ul><h2 id="三、rocketmq-的定时消息" tabindex="-1"><a class="header-anchor" href="#三、rocketmq-的定时消息"><span>三、RocketMQ 的定时消息</span></a></h2><p>RocketMQ 支持任意秒级的定时消息，如下图所示</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-814d93bb-4ac7-42a3-aef5-3642cc952568.jpg" alt="阿里云开发者：RocketMQ的定时消息" tabindex="0" loading="lazy"><figcaption>阿里云开发者：RocketMQ的定时消息</figcaption></figure><p>使用门槛低，只需要在发送消息的时候设置延时时间即可，以 java 代码为例：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MessageBuilder</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> messageBuilder </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> deliverTimeStamp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentTimeMillis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 15L</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 60</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 延迟15分钟</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Message</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> message </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> messageBuilder</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTopic</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;topic&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 设置消息索引键，可根据关键字精确查找某条消息。</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setKeys</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;messageKey&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;messageTag&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 设置延时时间</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setDeliveryTimestamp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(deliverTimeStamp)</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 消息体</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setBody</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;messageBody&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getBytes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">build</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">SendReceipt</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sendReceipt </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> producer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">send</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(message);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">sendReceipt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getMessageId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="rocketmq-的定时消息是如何实现的呢" tabindex="-1"><a class="header-anchor" href="#rocketmq-的定时消息是如何实现的呢"><span>RocketMQ 的定时消息是如何实现的呢？</span></a></h3><p>在 RocketMQ 中，使用了经典的时间轮算法。通过 TimerWheel 来描述时间轮不同的时刻，通过 TimerLog 来记录不同时刻的消息。</p><p>TimerWheel 中的每一格代表着一个时刻，同时会有一个 firstPos 指向这个刻度下所有定时消息的首条 TimerLog 记录的地址，一个 lastPos 指向这个刻度下所有定时消息最后一条 TimerLog 的记录的地址。并且，对于所处于同一个刻度的的消息，其 TimerLog 会通过 prevPos 串联成一个链表。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-5b1d87d8-acc3-4c35-9048-eac2f062c283.jpg" alt="阿里云开发者：RocketMQ TimerWheel" tabindex="0" loading="lazy"><figcaption>阿里云开发者：RocketMQ TimerWheel</figcaption></figure><p>当需要新增一条记录的时候，例如现在我们要新增一个 “1-4”。那么就将新记录的 prevPos 指向当前的 lastPos，即 “1-3”，然后修改 lastPos 指向 “1-4”。这样就将同一个刻度上面的 TimerLog 记录全都串起来了。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-128965a5-d8ad-4d29-8ffd-68035925b940.jpg" alt="阿里云开发者：TimerLog" tabindex="0" loading="lazy"><figcaption>阿里云开发者：TimerLog</figcaption></figure><p>优点</p><ul><li>精度高，支持任意时刻。</li><li>使用门槛低，和使用普通消息一样。</li></ul><p>缺点</p><ul><li>使用限制：定时时长最大值 24 小时。</li><li>成本高：每个订单需要新增一个定时消息，且不会马上消费，给 MQ 带来很大的存储成本。</li><li>同一个时刻大量消息会导致消息延迟：定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</li></ul><h2 id="四、redis-的过期监听" tabindex="-1"><a class="header-anchor" href="#四、redis-的过期监听"><span>四、Redis 的过期监听</span></a></h2><p>Redis 支持过期监听，也能达到和 RocketMQ 定时消息一样的能力，具体步骤如下：</p><p>①、redis 配置文件开启&quot;notify-keyspace-events Ex&quot;</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-90f3b173-7cf5-4847-ad65-47d8a6db0814.jpg" alt="阿里云开发者：redis 配置文件" tabindex="0" loading="lazy"><figcaption>阿里云开发者：redis 配置文件</figcaption></figure><p>②、监听 key 的过期回调，以 Java 代码为例</p><p>RedisListenerConfig</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RedisListenerConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    RedisMessageListenerContainer</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> container</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RedisConnectionFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> factory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        RedisMessageListenerContainer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> container</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> RedisMessageListenerContainer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        container</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setConnectionFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(factory);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> container;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>RedisKeyExpirationListerner</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RedisKeyExpirationListener</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> KeyExpirationEventMessageListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> RedisKeyExpirationListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RedisMessageListenerContainer</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> listenerContainer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(listenerContainer);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> onMessage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Message</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> message</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> expiredKey</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> message</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;监听到key：&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> expiredKey </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;已过期&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 Redis 进行订单超时处理的流程图如下</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-b96143c3-674e-4689-a10b-adc6d16b7fb5.jpg" alt="阿里云开发者：Redis 订单超时" tabindex="0" loading="lazy"><figcaption>阿里云开发者：Redis 订单超时</figcaption></figure><p>这个方案表面看起来没问题，但是在实际生产上不推荐，我们来看下 Redis 过期时间的原理</p><p>每当我们对一个 key 设置了过期时间，Redis 就会把该 key 带上过期时间，存到过期字典中，在 redisDb 中通过 expires 字段维护：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct redisDb {</span></span>
<span class="line"><span>    dict *dict;    /* Maintains all key-value pairs */</span></span>
<span class="line"><span>    dict *expires; /* Expiration dictionary, maintains keys with set expiration times */</span></span>
<span class="line"><span>    // Other members can be added here</span></span>
<span class="line"><span>} redisDb;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>过期字典本质上是一个链表，每个节点的数据结构结构如下：</p><ul><li>key 是一个指针，指向某个键对象。</li><li>value 是一个 long long 类型的整数，保存了 key 的过期时间。</li></ul><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-480fdca3-724b-4159-8fc8-be44a4d3e43a.jpg" alt="阿里云开发者：过期字典" tabindex="0" loading="lazy"><figcaption>阿里云开发者：过期字典</figcaption></figure><p>Redis 主要使用了定期删除和惰性删除策略来进行过期 key 的删除</p><ul><li>定期删除：每隔一段时间（默认 100ms）就<strong>随机抽取</strong>一些设置了过期时间的 key，检查其是否过期，如果有过期就删除。之所以这么做，是为了通过限制删除操作的执行时长和频率来减少对 cpu 的影响。不然每隔 100ms 就要遍历所有设置过期时间的 key，会导致 cpu 负载太大。</li><li>惰性删除：不主动删除过期的 key，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。惰性删除有一个问题，如果这个 key 已经过期了，但是一直没有被访问，就会一直保存在数据库中。</li></ul><p>从以上的原理可以得知，Redis 过期删除是不精准的，在订单超时处理的场景下，惰性删除基本上也用不到，无法保证 key 在过期的时候可以立即删除，更不能保证能立即通知。如果订单量比较大，那么延迟几分钟也是有可能的。</p><p>Redis 过期通知也是不可靠的，Redis 在过期通知的时候，如果应用正好重启了，那么就有可能通知事件就丢了，会导致订单一直无法关闭，有稳定性问题。如果一定要使用 Redis 过期监听方案，建议再通过定时任务做补偿机制。</p><h2 id="五、定时任务分布式批处理" tabindex="-1"><a class="header-anchor" href="#五、定时任务分布式批处理"><span>五、定时任务分布式批处理</span></a></h2><p>定时任务分布式批处理解决方案，即通过定时任务不停轮询数据库的订单，将已经超时的订单捞出来，分发给不同的机器分布式处理：</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-b518d126-4e3c-402e-9ff2-c162c0f59352.jpg" alt="阿里云开发者：定时任务分布式批处理" tabindex="0" loading="lazy"><figcaption>阿里云开发者：定时任务分布式批处理</figcaption></figure><p>使用定时任务分布式批处理的方案具有如下优势：</p><ul><li><strong>稳定性强：</strong> 基于通知的方案（比如 MQ 和 Redis），比较担心在各种极端情况下导致通知的事件丢了。使用定时任务跑批，只需要保证业务幂等即可，如果这个批次有些订单没有捞出来，或者处理订单的时候应用重启了，下一个批次还是可以捞出来处理，稳定性非常高。</li><li><strong>效率高：</strong> 基于 MQ 的方案，需要一个订单一个定时消息，consumer 处理定时消息的时候也需要一个订单一个订单更新，对数据库 tps 很高。使用定时任务跑批方案，一次捞出一批订单，处理完了，可以批量更新订单状态，减少数据库的 tps。在海量订单处理场景下，批量处理效率最高。</li><li><strong>可运维：</strong> 基于数据库存储，可以很方便的对订单进行修改、暂停、取消等操作，所见即所得。如果业务跑失败了，还可以直接通过 sql 修改数据库来进行批量运维。</li><li><strong>成本低：</strong> 相对于其他解决方案要借助第三方存储组件，复用数据库的成本大大降低。</li></ul><p>但是使用定时任务有个天然的缺点：没法做到精度很高。定时任务的延迟时间，由定时任务的调度周期决定。如果把频率设置很小，就会导致数据库的 qps 比较高，容易造成数据库压力过大，从而影响线上的正常业务。</p><p>所以一般需要抽离出超时中心和超时库来单独做订单的超时调度，在阿里内部，几乎所有的业务都使用<strong>基于定时任务分布式批处理的超时中心来做订单超时处理</strong>，SLA 可以做到 30 秒以内：</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-8be5574e-de63-4da5-87db-e1a214461ed6.jpg" alt="阿里云开发者：SLA" tabindex="0" loading="lazy"><figcaption>阿里云开发者：SLA</figcaption></figure><p>如何让超时中心不同的节点协同工作，拉取不同的数据？</p><p>通常的解决方案是借助任务调度系统，开源任务调度系统大多支持分片模型，比较适合做分库分表的轮询，比如一个分片代表一张分表。但是如果分表特别多，分片模型配置起来还是比较麻烦的。另外如果只有一张大表，或者超时中心使用其他的存储，这两个模型就不太适合。</p><p>阿里巴巴分布式任务调度系统 SchedulerX，不但兼容主流开源任务调度系统和 Spring @Scheduled 注解，还自研了轻量级 MapReduce 模型，针对任意异构数据源，简单几行代码就可以实现海量数据秒级别跑批。</p><p>①、通过实现 map 函数，通过代码自行构造分片，SchedulerX 会将分片平均分给超时中心的不同节点分布式执行。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-b11aced9-af6a-4946-a142-490d0d11bd0c.jpg" alt="阿里云开发者：map 函数" tabindex="0" loading="lazy"><figcaption>阿里云开发者：map 函数</figcaption></figure><p>②、通过实现 reduce 函数，可以做聚合，可以判断这次跑批有哪些分片跑失败了，从而通知下游处理。</p><figure><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-da94dbc9-e768-4a51-8888-3086c2e76e0a.jpg" alt="阿里云开发者：reduce 函数" tabindex="0" loading="lazy"><figcaption>阿里云开发者：reduce 函数</figcaption></figure><p>使用 SchedulerX 定时跑批解决方案，还具有如下优势：</p><ul><li><strong>免运维、成本低：</strong> 不需要自建任务调度系统，由云上托管。</li><li><strong>可观测：</strong> 提供任务执行的历史记录、查看堆栈、日志服务、链路追踪等能力。</li><li><strong>高可用：</strong> 支持同城双活容灾，支持多种渠道的监控报警。</li><li><strong>混部：</strong> 可以托管阿里云的机器，也可以托管非阿里云的机器。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>如果对于超时精度比较高，超时时间在 24 小时内，且不会有峰值压力的场景，推荐使用 RocketMQ 的定时消息解决方案。</p><p>在电商业务下，许多订单超时场景都在 24 小时以上，对于超时精度没有那么敏感，并且有海量订单需要批处理，推荐使用基于定时任务的跑批解决方案。</p><blockquote><p>参考链接：<a href="https://mp.weixin.qq.com/s/OmbyxkufVm-XzwIv_A514w" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/OmbyxkufVm-XzwIv_A514w</a>，整理：沉默王二</p></blockquote>`,90),l=[n];function p(r,h){return e(),s("div",null,l)}const c=i(t,[["render",p],["__file","dingscszmclwmyzcfa.html.vue"]]),g=JSON.parse('{"path":"/nice-article/weixin/dingscszmclwmyzcfa.html","title":"订单超时怎么处理？我们用这种方案","lang":"zh-CN","frontmatter":{"title":"订单超时怎么处理？我们用这种方案","shortTitle":"订单超时怎么处理？我们用这种方案","description":"本文介绍了订单超时的几种方案及分析。","author":"黄晓萌(学仁)","category":["微信公众号"],"head":[["meta",{"property":"og:url","content":"https://javabetter.cn/nice-article/weixin/dingscszmclwmyzcfa.html"}],["meta",{"property":"og:site_name","content":"二哥的Java进阶之路"}],["meta",{"property":"og:title","content":"订单超时怎么处理？我们用这种方案"}],["meta",{"property":"og:description","content":"本文介绍了订单超时的几种方案及分析。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-40480773-4e86-49fc-b283-bc0a3948f0ca.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-18T12:55:35.000Z"}],["meta",{"property":"article:author","content":"黄晓萌(学仁)"}],["meta",{"property":"article:modified_time","content":"2024-11-18T12:55:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"订单超时怎么处理？我们用这种方案\\",\\"image\\":[\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-40480773-4e86-49fc-b283-bc0a3948f0ca.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-525e94ca-96e1-4308-a010-fc96702fb6ef.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-1937308e-17bd-4fa4-af0d-7df1c2887b10.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-814d93bb-4ac7-42a3-aef5-3642cc952568.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-5b1d87d8-acc3-4c35-9048-eac2f062c283.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-128965a5-d8ad-4d29-8ffd-68035925b940.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-90f3b173-7cf5-4847-ad65-47d8a6db0814.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-b96143c3-674e-4689-a10b-adc6d16b7fb5.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-480fdca3-724b-4159-8fc8-be44a4d3e43a.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-b518d126-4e3c-402e-9ff2-c162c0f59352.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-8be5574e-de63-4da5-87db-e1a214461ed6.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-b11aced9-af6a-4946-a142-490d0d11bd0c.jpg\\",\\"http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin//dingscszmclwmyzcfa-da94dbc9-e768-4a51-8888-3086c2e76e0a.jpg\\"],\\"dateModified\\":\\"2024-11-18T12:55:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"黄晓萌(学仁)\\"}]}"]]},"headers":[{"level":2,"title":"一、JDK 自带的延时队列","slug":"一、jdk-自带的延时队列","link":"#一、jdk-自带的延时队列","children":[]},{"level":2,"title":"二、RabbitMQ 延时消息","slug":"二、rabbitmq-延时消息","link":"#二、rabbitmq-延时消息","children":[]},{"level":2,"title":"三、RocketMQ 的定时消息","slug":"三、rocketmq-的定时消息","link":"#三、rocketmq-的定时消息","children":[{"level":3,"title":"RocketMQ 的定时消息是如何实现的呢？","slug":"rocketmq-的定时消息是如何实现的呢","link":"#rocketmq-的定时消息是如何实现的呢","children":[]}]},{"level":2,"title":"四、Redis 的过期监听","slug":"四、redis-的过期监听","link":"#四、redis-的过期监听","children":[]},{"level":2,"title":"五、定时任务分布式批处理","slug":"五、定时任务分布式批处理","link":"#五、定时任务分布式批处理","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1730775957000,"updatedTime":1731934535000,"contributors":[{"name":"沉默王二","email":"www.qing_gee@163.com","commits":1}]},"readingTime":{"minutes":12.98,"words":3893},"filePathRelative":"nice-article/weixin/dingscszmclwmyzcfa.md","localizedDate":"2024年11月5日","excerpt":"<p>这是一道场景题，当面试官问：</p>\\n<ul>\\n<li>订单超时怎么处理？</li>\\n<li>用户下单后有一个延迟 15 分钟的支付订单，怎么处理？</li>\\n</ul>\\n<p>我们该怎么回答呢？我在阿里云开发者账号上看到一个非常不错的内容，这里整理了一下分享给大家作为参考。</p>\\n<p>参考答案：</p>\\n<p>延迟支付订单的场景可以采用消息队列的延迟任务方案。即在用户下单时，将订单放入一个延迟队列中，延迟 15 分钟检查支付状态，超时未支付则取消订单。这种方式可以在高并发下有效降低系统负担，减少数据库轮询压力，并通过消息队列的自动调度机制确保订单准时处理。同时，这个设计可以通过消息的幂等性、分布式部署等手段提升系统的可靠性和扩展性。</p>"}');export{c as comp,g as data};
